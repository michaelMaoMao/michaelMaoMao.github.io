<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Runtime的魔法世界"><meta name="keywords" content="iOS101"><meta name="author" content="MichaelMao"><meta name="copyright" content="MichaelMao"><title>Runtime的魔法世界 | MMao</title><link rel="shortcut icon" href="/images/my-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.5.6"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.6"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.5.6"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://unpkg.com"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitment/style/default.min.css"><script src="https://cdn.jsdelivr.net/npm/gitment/dist/gitment.browser.min.js"></script><link rel="manifest" href="/manifest.json"><link rel="manifest" href="/manifest.json"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script><meta name="generator" content="Hexo 7.3.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81Runtime%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E6%9C%BA%E5%88%B6"><span class="toc-number">1.</span> <span class="toc-text">一、Runtime运行时的机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Runtime%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">2.</span> <span class="toc-text">二、Runtime运行时的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81Runtime%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">3.</span> <span class="toc-text">三、Runtime运行时的优点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Runtime-%E7%9A%84%E6%9C%AF%E8%AF%AD"><span class="toc-number">4.</span> <span class="toc-text">Runtime 的术语</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#objc-object"><span class="toc-number">4.1.</span> <span class="toc-text">objc_object</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#objc-class"><span class="toc-number">4.2.</span> <span class="toc-text">objc_class</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#isa"><span class="toc-number">4.3.</span> <span class="toc-text">isa</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SEL"><span class="toc-number">4.4.</span> <span class="toc-text">SEL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IMP"><span class="toc-number">4.5.</span> <span class="toc-text">IMP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Method"><span class="toc-number">4.6.</span> <span class="toc-text">Method</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6"><span class="toc-number">5.</span> <span class="toc-text">四、消息机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">5.0.1.</span> <span class="toc-text">方法的调用流程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#objc-msgSend"><span class="toc-number">5.0.1.1.</span> <span class="toc-text">objc_msgSend</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-number">5.0.2.</span> <span class="toc-text">重定向</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E6%9C%BA%E5%88%B6"><span class="toc-number">5.0.3.</span> <span class="toc-text">消息转发机制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#respondsToSelector"><span class="toc-number">5.0.3.1.</span> <span class="toc-text">respondsToSelector</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%8A%A8%E6%80%81%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90"><span class="toc-number">5.0.3.2.</span> <span class="toc-text">1. 动态方法解析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%A4%87%E7%94%A8%E6%8E%A5%E6%94%B6%E8%80%85"><span class="toc-number">5.0.3.3.</span> <span class="toc-text">2. 备用接收者</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%AE%8C%E6%95%B4%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91"><span class="toc-number">5.0.3.4.</span> <span class="toc-text">3. 完整消息转发</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E7%9A%84%E8%BD%AC%E5%8F%91%E6%9C%BA%E5%88%B6"><span class="toc-number">5.0.4.</span> <span class="toc-text">消息的转发机制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Runtime%E5%AE%9E%E6%88%98"><span class="toc-number">6.</span> <span class="toc-text">Runtime实战</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#method-invoke"><span class="toc-number">6.1.</span> <span class="toc-text">method_invoke</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Runtime%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B"><span class="toc-number">6.2.</span> <span class="toc-text">Runtime应用举例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Runtime%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">7.</span> <span class="toc-text">Runtime的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9C%A8Runtime%E4%B8%AD%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="toc-number">8.</span> <span class="toc-text">类在Runtime中的表示</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%96%B9%E6%B3%95-%E5%B1%9E%E6%80%A7%E7%AD%89%E5%88%97%E8%A1%A8"><span class="toc-number">8.1.</span> <span class="toc-text">获取方法&#x2F;属性等列表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">9.</span> <span class="toc-text">参考</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://pic-mike.oss-cn-hongkong.aliyuncs.com/Blog/avatar.png"></div><div class="author-info__name text-center">MichaelMao</div><div class="author-info__description text-center">stay on your way</div><div class="follow-button"><a href="https://github.com/FrizzleFur">Follow me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">45</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">23</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="https://juejin.im/user/57f8ffda2e958a005581e3c0/posts">J_Knight</a><a class="author-info-links__name text-center" href="https://halfrost.com/">Halfrost</a><a class="author-info-links__name text-center" href="https://github.com/draveness/analyze">draveness</a><a class="author-info-links__name text-center" href="https://juejin.im/user/5a52075e6fb9a01c9d31b107/posts">老司机周报</a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">MMao</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/ideas">思所</a><a class="site-page" href="/booknotes">读书</a><a class="site-page" href="/about">关于</a><a class="site-page" href="/gallery">相册</a><a class="site-page" href="/gtd">GTD</a></span></div><div id="post-info"><div id="post-title">Runtime的魔法世界</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2017-12-31</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><blockquote>
<p> <code>Runtime</code>一直被一些开发者津津乐道，它强大的API可以帮助你更好的理解OC的运行时机制，也是项目中不可缺少的“黑魔法”。本篇将结合一些优秀的<code>Runtime</code>文章，简单介绍<code>Runtime</code>原理以及其应用。</p>
</blockquote>
<h2 id="一、Runtime运行时的机制"><a href="#一、Runtime运行时的机制" class="headerlink" title="一、Runtime运行时的机制"></a>一、<code>Runtime</code>运行时的机制</h2><ul>
<li><p>对于C语言，函数的调用在编译的时候会决定调用哪个函数。 在编译阶段，C语言调用未实现的函数就会报错。</p>
</li>
<li><p>对于<code>Objective-C</code>的函数，属于动态调用过程，在编译的时候并不能决定真正调用哪个函数，只有在真正运行的时候才会根据函数的名称找到对应的函数来调用。在编译阶段，<code>Objective-C</code>可以调用任何函数，即使这个函数并未实现，只要声明过就不会报错。</p>
</li>
<li><p><code>Objective-C</code>语言是一门动态语言，它将很多静态语言在编译和链接时期做的事放到了运行时来处理。这种动态语言的优势在于：我们写代码时更具灵活性，如我们可以把消息转发给我们想要的对象，或者随意交换一个方法的实现等。</p>
</li>
<li><p>这种特性意味着<code>Objective-C</code>不仅需要一个编译器，还需要一个运行时系统来执行编译的代码。对于<code>Objective-C</code>来说，这个运行时系统就像一个操作系统一样：它让所有的工作可以正常的运行。这个运行时系统即<code>Objc Runtime</code>。<code>Objc Runtime</code>其实是一个<code>Runtime</code>库，它基本上是用C和汇编写的，这个库使得C语言有了面向对象的能力。</p>
</li>
</ul>
<span id="more"></span>

<h2 id="二、Runtime运行时的作用"><a href="#二、Runtime运行时的作用" class="headerlink" title="二、Runtime运行时的作用"></a>二、<code>Runtime</code>运行时的作用</h2><ul>
<li>能获得某个类的所有成员变量</li>
<li>能获得某个类的所有属性</li>
<li>能获得某个类的所有方法</li>
<li>交换方法实现</li>
<li>能动态添加一个成员变量</li>
<li>能动态添加一个属性</li>
<li>字典转模型</li>
<li><code>Runtime</code>归档&#x2F;反归档</li>
</ul>
<h2 id="三、Runtime运行时的优点"><a href="#三、Runtime运行时的优点" class="headerlink" title="三、Runtime运行时的优点"></a>三、<code>Runtime</code>运行时的优点</h2><ol>
<li>实现多继承<code>Multiple Inheritance</code></li>
<li><code>Method Swizzling</code></li>
<li>面向切面编程<code>Aspect Oriented Programming</code>（在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。）</li>
<li><code>Isa Swizzling</code> </li>
<li>使用<code>Associated Object</code>关联对象</li>
<li>动态的添加方法</li>
<li><code>NSCoding</code>的自动归档和自动解档</li>
<li>字典和模型互相转换</li>
</ol>
<h2 id="Runtime-的术语"><a href="#Runtime-的术语" class="headerlink" title="Runtime 的术语"></a><code>Runtime</code> 的术语</h2><blockquote>
<p>先明白<code>Runtime</code>的一些常用术语</p>
</blockquote>
<ol>
<li><code>objc_object</code> ：<code>Objective-C</code>对象的定义，根据其<code>isa</code>指针就可以顺藤摸瓜找到对象所属的类</li>
<li><code>objc_class</code> ： <code>Objective-C</code>类的定义，类也是一种对象，<strong>类方法可以理解成类对象的实例方法。每个类仅有一个类对象，而每个类对象仅有一个与之相关的元类</strong></li>
<li><code>isa指针</code>：<code>Objective-C</code>中，类和类的实例在本质上没有区别，都是对象，任何对象都有<code>isa</code>指针，它指向类或元类（元类后面会讲解）。</li>
<li><code>SEL</code>：<code>SEL</code>方法选择器，是<strong>方法名<code>selector</code>的指针</strong>。方法的<code>selector</code>表示<strong>运行时方法的名字</strong>。<code>Objective-C</code>在编译时，会依据每一个方法的名字、参数，生成一个唯一的<strong>整型标识</strong>(Int类型的地址)，这个标识就是<code>SEL</code>。</li>
<li><code>IMP</code>：<code>IMP</code>是一个<strong>函数指针</strong>，指向方法最终实现的首地址。<code>SEL</code>就是为了查找方法的最终实现<code>IMP</code>。</li>
<li><code>Method</code>：用于表示类定义中的方法，它的结构体中包含一个<code>SEL</code>和<code>IMP</code>，相当于在<code>SEL</code>和<code>IMP</code>之间作了一个映射。</li>
<li>消息机制：任何方法的调用本质就是发送一个消息。编译器会将消息表达式<code>[receiver message]</code>转化为一个消息函数<code>objc_msgSend(receiver, selector)</code>。</li>
</ol>
<h3 id="objc-object"><a href="#objc-object" class="headerlink" title="objc_object"></a><code>objc_object</code></h3><p>常见的<code>id</code> 它是一个指向类实例（<code>objc_object</code>类型）的指针 <code> typedef struct objc_object *id;</code></p>
<p>而<code>objc_object</code>类型的结构如下</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_object &#123;</span><br><span class="line">private:</span><br><span class="line">    isa_t isa;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ISA() assumes this is NOT a tagged pointer object</span></span><br><span class="line">    Class ISA();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getIsa() allows this to be a tagged pointer object</span></span><br><span class="line">    Class getIsa();</span><br><span class="line">    ... 此处省略其他方法声明</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据 <code>isa</code> 就可以顺藤摸瓜找到对象所属的类；<br>由此可见，所有的<code>Objective-C</code>类和对象，在<code>Runtime</code>层都是用<code>struct</code>结构表示。</p>
<h3 id="objc-class"><a href="#objc-class" class="headerlink" title="objc_class"></a><code>objc_class</code></h3><p>类的定义</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// An opaque type that represents an Objective-C class.</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</span><br></pre></td></tr></table></figure>
<p><code>objc_class</code>的定义</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_class &#123;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !__OBJC2__</span></span><br><span class="line">    Class super_class                                        OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">const</span> <span class="type">char</span> *name                                         OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="type">long</span> version                                             OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="type">long</span> info                                                OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="type">long</span> instance_size                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_method_list **methodLists                    OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_cache *cache                                 OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="comment">/* Use `Class` instead of `struct objc_class *` */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>在版本<code>objc4-680</code>的<code>Runtime</code>源码中的数据结构定义中</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_class : objc_object &#123;</span><br><span class="line">    <span class="comment">// Class ISA;</span></span><br><span class="line">    Class superclass;</span><br><span class="line">    cache_t cache;             <span class="comment">// formerly cache pointer and vtable</span></span><br><span class="line">    class_data_bits_t bits;    <span class="comment">// class_rw_t * plus custom rr/alloc flags</span></span><br><span class="line">    class_rw_t *data() &#123; </span><br><span class="line">        <span class="keyword">return</span> bits.data();</span><br><span class="line">    &#125;</span><br><span class="line">    ... 省略其他方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到<code>objc_class</code>是继承<code>objc_object</code>的，说明<code>ObjC</code> 类本身同时也是一个对象。为了处理类和对象的关系，<code>Runtime</code> 库创建了一种叫做元类 (<code>Meta Class</code>) 的概念，类对象所属类型就叫做元类，它用来表述类对象本身所具备的元数据（类方法等）</p>
<p><strong>类方法可以理解成类对象的实例方法。每个类仅有一个类对象，而每个类对象仅有一个与之相关的元类</strong></p>
<p>当你发出一个类似<code> [NSObject alloc]</code> 的消息时，你事实上是把这个消息发给了一个类对象 (<code>Class Object</code>) ，这个类对象必须是一个元类的实例，而这个元类同时也是一个根元类 (<code>root meta class</code>) 的实例。所有的元类最终都指向根元类为其超类。</p>
<p>所有的元类的方法列表都有能够响应消息的类方法。所以当 <code>[NSObject alloc]</code> 这条消息发给类对象的时候，<code>objc_msgSend()</code> 会去它的元类里面去查找能够响应消息的方法，如果找到了，然后对这个类对象执行方法调用。</p>
<h3 id="isa"><a href="#isa" class="headerlink" title="isa"></a><code>isa</code></h3><p>根据 <code>isa</code> 就可以顺藤摸瓜找到对象所属的类<br>PS: <code>isa</code> 指针不总是指向实例对象所属的类，不能依靠它来确定类型，而是应该用 <code>class</code> 方法来确定实例对象的类。因为<code>KVO</code>的实现机理就是将被观察对象的 isa 指针指向一个中间类而不是真实的类</p>
<h3 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a><code>SEL</code></h3><p><code>SEL</code> 区分方法的 <code>ID</code>，而这个 <code>ID</code> 的数据结构是<code>SEL</code>,其实它就是个映射到方法的C字符串，你可以用 <code>Objc</code> 编译器命令 <code>@selector()</code> 或者 <code>Runtime</code> 系统的 <code>sel_registerName</code> 函数来获得一个 <code>SEL</code> 类型的方法选择器。<br>它是一个模仿C的构造指针类型的对象，可以定义很多方法指针。 常作为形参。 用于运行时或者多类之间隔文件 传递方法。</p>
<ul>
<li><code>@selector</code>是查找当前类的实例方法，而<code>[object @selector(方法名:方法参数..) ]</code> ;是取object所属类的实例方法.</li>
<li>查找类方法时，除了方法名,方法参数也查询条件之一.</li>
<li>可以运行中用<code>SEL</code>变量反向查出方法名字字符串</li>
</ul>
<ol>
<li>方法的存储位置</li>
</ol>
<ul>
<li>每个类的方法列表都存储在类对象中 （<code>struct objc_method_list **methodLists</code>）</li>
<li>每个方法都有一个与之对应的<code>SEL</code>类型的对象（方法名的指针）根据<code>SEL</code>对象就可以找到对应方法的地址，进而调用该方法。</li>
</ul>
<ol start="2">
<li><code>SEL</code>对象的创建</li>
</ol>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SEL sel = <span class="keyword">@selector</span>(testMethodName);</span><br><span class="line">SEL sel2 = <span class="built_in">NSSelectorFromString</span>(<span class="string">@&quot;testMethodName&quot;</span>);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><code>SEL</code>对象转<code>NSString</code></li>
</ol>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *testSelStr = <span class="built_in">NSStringFromSelector</span>(sel2);</span><br><span class="line"><span class="built_in">NSString</span> *testClassStr = <span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>]);</span><br><span class="line">SEL sel = <span class="built_in">NSSelectorFromString</span>(<span class="string">@&quot;testMethodName&quot;</span>);</span><br><span class="line">[<span class="keyword">self</span> performSelector:sel]</span><br></pre></td></tr></table></figure>

<h3 id="IMP"><a href="#IMP" class="headerlink" title="IMP"></a><code>IMP</code></h3><p><code>IMP</code>实际上是一个函数指针，指向方法实现的首地址。其定义如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> !OBJC_OLD_DISPATCH_PROTOTYPES</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> (*IMP)(<span class="type">void</span> <span class="comment">/* id, SEL, ... */</span> );</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">id</span> (*IMP)(<span class="type">id</span>, SEL, ...);</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>

<p>这个函数使用当前 CPU 架构实现的标准的 C 调用约定。第一个参数是指向 <code>self</code> 的指针(如果是实例方法，则是类实例的内存地址；如果是类方法，则是指向元类的指针)，第二个参数是方法选择器(<code>selector</code>)，接下来是方法的实际参数列表。<br>前面介绍过的 <code>SEL</code> 就是为了查找方法的最终实现 <code>IMP</code> 的。由于每个方法对应唯一的 <code>SEL</code>，因此我们可以通过 <code>SEL</code> 方便快速准确地获得它所对应的 <code>IMP</code>，查找过程将在下面讨论。取得 <code>IMP</code> 后，我们就获得了执行这个方法代码的入口点，此时，我们就可以像调用普通的 C 语言函数一样来使用这个函数指针了。<br>通过取得 <code>IMP</code>，我们可以跳过 <code>Runtime</code> 的消息传递机制，直接执行 <code>IMP</code> 指向的函数实现，这样省去了 <code>Runtime</code> 消息传递过程中所做的一系列查找操作，会比直接向对象发送消息高效一些。</p>
<h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a><code>Method</code></h3><p>介绍完 <code>SEL</code> 和 <code>IMP</code>，我们就可以来讲讲 <code>Method</code> 了。<code>Method</code> 用于表示类定义中的方法，则定义如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_method *Method;</span><br><span class="line"><span class="keyword">struct</span> objc_method &#123;</span><br><span class="line">    SEL method_name                 OBJC2_UNAVAILABLE;  <span class="comment">// 方法名</span></span><br><span class="line">    <span class="type">char</span> *method_types                  OBJC2_UNAVAILABLE;</span><br><span class="line">    IMP method_imp                      OBJC2_UNAVAILABLE;  <span class="comment">// 方法实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到该结构体中包含一个 <code>SEL</code> 和 <code>IMP</code>，实际上相当于在 <code>SEL</code> 和 <code>IMP</code> 之间作了一个映射。有了 <code>SEL</code>，我们便可以找到对应的 <code>IMP</code>，从而调用方法的实现代码。</p>
<p><code>objc_method_description</code>定义了一个<code>Objective-C</code>方法，其定义如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_method_description &#123;</span><br><span class="line">	SEL name;               <span class="comment">/**&lt; The name of the method */</span></span><br><span class="line">	<span class="type">char</span> *types;            <span class="comment">/**&lt; The types of the method arguments */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="四、消息机制"><a href="#四、消息机制" class="headerlink" title="四、消息机制"></a>四、消息机制</h2><blockquote>
<p>消息发送（<code>Messaging</code>）是 <strong><code>Runtime</code> 通过 <code>selector</code> 快速查找 <code>IMP</code> 的过程</strong>，有了函数指针就可以执行对应的方法实现；**消息转发（<code>Message Forwarding</code>）是在查找 <code>IMP</code> 失败后执行一系列转发流程的慢速通道，如果不作转发处理，则会打日志和抛出异常。<br>**<br><img src="http://pic-mike.oss-cn-hongkong.aliyuncs.com/qiniu/15143584958990.jpg" alt="Objective-C消息发送和转发流程图"></p>
</blockquote>
<p>当执行了<code>[receiver message]</code>的时候，相当于向<code>receiver</code>发送一条消息<code>message</code>。<code>Runtime</code>会根据<code>reveiver</code>能否处理这条<code>message</code>，从而做出不同的反应。</p>
<h4 id="方法的调用流程"><a href="#方法的调用流程" class="headerlink" title="方法的调用流程"></a>方法的调用流程</h4><p>消息直到运行时才绑定到方法的实现上。编译器会将消息表达式<code>[receiver message]</code>转化为一个消息函数，即<code>objc_msgSend(receiver, selector)</code>。	<br><img src="http://pic-mike.oss-cn-hongkong.aliyuncs.com/qiniu/2017-08-15-15027671461420.png"></p>
<h5 id="objc-msgSend"><a href="#objc-msgSend" class="headerlink" title="objc_msgSend"></a>objc_msgSend</h5><p>Objective-C 方法的调用，会转换成消息发送的代码，如 id objc_msgSend(id self, SEL op, …);</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyClass *myObject = [[MyClass alloc] initWithString:<span class="string">@&quot;someString&quot;</span>];</span><br></pre></td></tr></table></figure>

<p>上述代码会被编译器转换成：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> myClass = objc_getClass(<span class="string">&quot;MyClass&quot;</span>);</span><br><span class="line">SEL allocSelector = <span class="keyword">@selector</span>(alloc);</span><br><span class="line">MyClass *myObject1 = objc_msgSend(myClass, allocSelector);</span><br><span class="line"></span><br><span class="line">SEL initSelector = <span class="keyword">@selector</span>(initWithString:);</span><br><span class="line">MyClass *myObject2 = objc_msgSend(myObject1, initSelector, <span class="string">@&quot;someString&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><code>objc_msgSend</code>做了如下事情：</p>
<ol>
<li>检测这个 <code>selector</code> 是不是要忽略的，或者是不是 nil 对象，是则忽略。</li>
<li>如果满足查找条件，通过对象的<code>isa</code>指针获取类的结构体。开始查找这个类的 <code>IMP</code>，先从 <code>cache</code> 里面找，完了找得到就跳到对应的函数去执行。</li>
<li>如果 <code>cache</code> 找不到就在类的方法分发表<code>objc_method_list</code>中查找</li>
<li>如果没有找到<code>selector</code>，则通过<code>objc_msgSend</code>结构体中指向父类的指针找到父类，并在父类的方法表里查找方法的<code>selector</code>。</li>
<li>依次会一直找到<code>NSObject</code>。</li>
<li>一旦找到<code>selector</code>，就会获取到方法实现<code>IMP</code>。</li>
<li>传入相应的参数来执行方法的具体实现。</li>
<li>如果最终没有定位到<code>selector</code>，就会走消息转发流程。</li>
</ol>
<p><img src="http://pic-mike.oss-cn-hongkong.aliyuncs.com/qiniu/15143579087191.jpg" alt="objc_msgSend流程"></p>
<h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><p>在消息转发机制执行前，<code>Runtime</code> 系统会再给我们一次偷梁换柱的机会，即通过重载<code>- (id)forwardingTargetForSelector:(SEL)aSelector</code>方法替换消息的接受者为其他对象</p>
<h4 id="消息转发机制"><a href="#消息转发机制" class="headerlink" title="消息转发机制"></a>消息转发机制</h4><p>以 <code>[receiver message]</code>的方式调用方法，如果<code>receiver</code>无法响应<code>message</code>，编译器会报错。但如果是以<code>performSelector</code>来调用，则需要等到运行时才能确定<code>object</code>是否能接收<code>message</code>消息。如果不能，则程序崩溃。<br>当我们不能确定一个对象是否能接收某个消息时，会先调用<code>respondsToSelector:</code>来判断一下
	</p>
<h5 id="respondsToSelector"><a href="#respondsToSelector" class="headerlink" title="respondsToSelector"></a><code>respondsToSelector</code></h5><ul>
<li>如果不使用<code>respondsToSelector:</code>来判断，那么这就可以用到“消息转发”机制。</li>
<li>当对象无法接收消息，就会启动消息转发机制，通过这一机制，告诉对象如何处理未知的消息。</li>
</ul>
<p>这样就可以采取一些措施，让程序执行特定的逻辑，从而避免崩溃。措施分为三个步骤。</p>
<h5 id="1-动态方法解析"><a href="#1-动态方法解析" class="headerlink" title="1. 动态方法解析"></a>1. 动态方法解析</h5><p>对象接收到未知的消息时，首先会调用所属类的类方法<code>+resolveInstanceMethod:(实例方法)</code>或 者<code>+resolveClassMethod:(类方法)</code>。<br>在这个方法中，我们有机会为该未知消息新增一个”处理方法”。使用该“处理方法”的前提是已经实现，只需要在运行时通过class_addMethod函数，动态的添加到类里面就可以了。代码如下。
	</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class_addMethod</span><br></pre></td></tr></table></figure>

<h5 id="2-备用接收者"><a href="#2-备用接收者" class="headerlink" title="2. 备用接收者"></a>2. 备用接收者</h5><p>如果在上一步无法处理消息，则Runtime会继续调下面的方法。</p>
<p><code>forwardingTargetForSelector</code><br>如果这个方法返回一个对象，则这个对象会作为消息的新接收者。注意这个对象不能是self自身，否则就是出现无限循环。如果没有指定对象来处理aSelector，则应该 return [super forwardingTargetForSelector:aSelector]。<br>但是我们只将消息转发到另一个能处理该消息的对象上，无法对消息进行处理，例如操作消息的参数和返回值。
	</p>
<h5 id="3-完整消息转发"><a href="#3-完整消息转发" class="headerlink" title="3. 完整消息转发"></a>3. 完整消息转发</h5><p>如果在上一步还是不能处理未知消息，则唯一能做的就是启用完整的消息转发机制。此时会调用以下方法：<br>	<br><code>forwardInvocation</code><br>这是最后一次机会将消息转发给其它对象。创建一个表示消息的NSInvocation对象，把与消息的有关全部细节封装在anInvocation中，包括selector，目标(target)和参数。在forwardInvocation 方法中将消息转发给其它对象。<br><code>forwardInvocation:</code>方法的实现有两个任务：
	</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a. 定位可以响应封装在anInvocation中的消息的对象。</span><br><span class="line">b. 使用anInvocation作为参数，将消息发送到选中的对象。anInvocation将会保留调用结果，runtime会提取这一结果并发送到消息的原始发送者。</span><br></pre></td></tr></table></figure>

<p>在这个方法中我们可以实现一些更复杂的功能，我们可以对消息的内容进行修改。另外，若发现消息不应由本类处理，则应调用父类的同名方法，以便继承体系中的每个类都有机会处理。<br>另外，必须重写下面的方法：
	</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">methodSignatureForSelector</span><br></pre></td></tr></table></figure>
<p>消息转发机制从这个方法中获取信息来创建NSInvocation对象。完整的示例如下：<br>	<br><code>NSObject</code>的<code>forwardInvocation</code>方法只是调用了<code>doesNotRecognizeSelector</code>方法，它不会转发任何消息。如果不在以上所述的三个步骤中处理未知消息，则会引发异常。<br><code>forwardInvocation</code>就像一个未知消息的分发中心，将这些未知的消息转发给其它对象。或者也可以像一个运输站一样将所有未知消息都发送给同一个接收对象，取决于具体的实现。</p>
<p>消息的转发机制可以用下图来帮助理解。<br>	<br><img src="http://pic-mike.oss-cn-hongkong.aliyuncs.com/qiniu/15134116331645.jpg" alt="消息的转发机制"></p>
<h4 id="消息的转发机制"><a href="#消息的转发机制" class="headerlink" title="消息的转发机制"></a>消息的转发机制</h4><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>可能很多童鞋初学<code> Objective-C</code> 时会把<code>[receiver message]</code>当成简单的方法调用，而无视了“发送消息”这句话的深刻含义。其实 <code>[receiver message]</code> 会被编译器转化为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSend(receiver, selector)</span><br></pre></td></tr></table></figure>
<p>如果消息含有参数，则为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSend(receiver, selector, arg1, arg2, ...)</span><br></pre></td></tr></table></figure>
<p>如果消息的接收者能够找到对应的 <code>selector</code>，那么就相当于直接执行了接收者这个对象的特定方法；否则，消息要么被转发，或是临时向接收者动态添加这个 <code>selector</code> 对应的实现内容，要么就干脆玩完崩溃掉。</p>
<p>现在可以看出 <code>[receiver message] </code>真的不是一个简简单单的方法调用。因为这只是在编译阶段确定了要向接收者发送 message 这条消息，而 receive 将要如何响应这条消息，那就要看运行时发生的情况来决定了。<br>从上述代码中可以看到，<code>objc_msgSend</code>（就arm平台而言）的消息分发分为以下几个步骤：</p>
<ul>
<li>判断<code>receiver</code>是否为nil，也就是objc_msgSend的第一个参数self，也就是要调用的那个方法所属对象</li>
<li>从缓存里寻找，找到了则分发，否则</li>
<li>利用objc-class.mm中<code>_class_lookupMethodAndLoadCache3</code>（为什么有个这么奇怪的方法。本文末尾会解释）方法去寻找<code>selector</code><ul>
<li>如果支持GC，忽略掉非GC环境的方法（retain等）</li>
<li>从本<code>class</code>的<code>method list</code>寻找<code>selector</code>，如果找到，填充到缓存中，并返回<code>selector</code>，否则</li>
<li>寻找父类的<code>method list</code>，并依次往上寻找，直到找到selector，填充到缓存中，并返回selector，否则</li>
<li>调用<code>_class_resolveMethod</code>，如果可以动态resolve为一个<code>selector</code>，不缓存，方法返回，否则</li>
<li>转发这个selector，否则</li>
</ul>
</li>
<li>报错，抛出异常</li>
</ul>
<p>当一个方法在比较“上层”的类中，用比较“下层”（继承关系上的上下层）对象去调用的时候，如果没有缓存，那么整个查找链是相当长的。就算方法是在这个类里面，当方法比较多的时候，每次都查找也是费事费力的一件事情。<br>考虑下面的一个调用过程：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; ++i) &#123;</span><br><span class="line">    MyClass *myObject = myObjects[i];</span><br><span class="line">    [myObject methodA];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们需要去调用一个方法数十万次甚至更多地时候，查找方法的消耗会变的非常显著。<br>就算我们平常的非大规模调用，除非一个方法只会调用一次，否则缓存都是有用的。在运行时，那么多对象，那么多方法调用，节省下来的时间也是非常可观的。<br>追本溯源，何为方法缓存<br>本着源码面前，了无秘密的原则，我们看下源码中的方法缓存到底是什么，在<code>objc-cache.mm</code>中，<code>objc_cache</code>的定义如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_cache &#123;</span><br><span class="line">    uintptr_t mask;            <span class="comment">/* total = mask + 1 */</span></span><br><span class="line">    uintptr_t occupied;       </span><br><span class="line">    cache_entry *buckets[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>嗯，<code>objc_cache</code>的定义看起来很简单，它包含了下面三个变量：<br>1)、<code>mask</code>：可以认为是当前能达到的最大index（从0开始的），所以缓存的size（total）是mask+1<br>2)、<code>occupied</code>：被占用的槽位，因为缓存是以散列表的形式存在的，所以会有空槽，而occupied表示当前被占用的数目<br>3)、<code>buckets</code>：用数组表示的hash表，<code>cache_entry</code>类型，每一个<code>cache_entry</code>代表一个方法缓存<br>(<code>buckets</code>定义在<code>objc_cache</code>的最后，说明这是一个可变长度的数组)<br>而<code>cache_entry</code>的定义如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    SEL name;     <span class="comment">// same layout as struct old_method</span></span><br><span class="line">    <span class="type">void</span> *unused;</span><br><span class="line">    IMP imp;  <span class="comment">// same layout as struct old_method</span></span><br><span class="line">&#125; cache_entry;</span><br></pre></td></tr></table></figure>
<p><code>cache_entry</code>定义也包含了三个字段，分别是：<br>1)、name，被缓存的方法名字<br>2)、unused，保留字段，还没被使用。<br>3)、imp，方法实现</p>
<h2 id="Runtime实战"><a href="#Runtime实战" class="headerlink" title="Runtime实战"></a>Runtime实战</h2><blockquote>
<p>我们知道App在项目开发过程中。由于不断迭代的业务逻辑和增加的模块，由于网络性能或者代码质量的或者项目Bug等问题，会出现App报出异常，出现崩溃的问题，如果次数多了会非常影响用户体验，在关键的模块，比如支付，登录等等，需要写很多校验就是防止出现异常。那么如何使用一种有效的手段来减少异常呢？</p>
</blockquote>
<p>其实<code>Runtime</code>就可以做到这点，在OC中，方法的调用在运行时会被编译成一个消息，在这个消息中不断去顺着isa指针在类或父类的元类的方法列表methodLists中寻找接受者，如果没有找到方法，就会开启消息转发机制。直接调用<code>[reciever methodName]</code></p>
<h3 id="method-invoke"><a href="#method-invoke" class="headerlink" title="method_invoke"></a><code>method_invoke</code></h3><blockquote>
<p>Calls the implementation of a specified method.</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Method method= class_getInstanceMethod([Son <span class="keyword">class</span>], <span class="keyword">@selector</span>(getNameWithfamily:));</span><br><span class="line"><span class="built_in">NSString</span> *invokeName= method_invoke(son,method,<span class="string">@&quot;Zhao&quot;</span>);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,invokeName);<span class="comment">// (Son Zhao)</span></span><br><span class="line"></span><br><span class="line">Method method= class_getInstanceMethod([father <span class="keyword">class</span>], <span class="keyword">@selector</span>(getNameWithfamily:));</span><br><span class="line"><span class="built_in">NSString</span> *invokeName= method_invoke(father,method,<span class="string">@&quot;Zhao&quot;</span>);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,invokeName);</span><br></pre></td></tr></table></figure>
<h3 id="Runtime应用举例"><a href="#Runtime应用举例" class="headerlink" title="Runtime应用举例"></a><code>Runtime</code>应用举例</h3><blockquote>
<p>设置按钮的快速点击的时间间隔</p>
</blockquote>
<p>建一个<code>UIControl</code>的分类，使用属性关联添加属性，并且交换<code>sendAction:to:forEvent:</code>的方法实现，</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  UIControl+Event.m</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="string">&quot;UIControl+Event.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&quot;objc/runtime.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIControl</span> (<span class="title">Event</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">char</span> acceptEventIntervalKey;</span><br><span class="line"><span class="keyword">static</span> <span class="type">char</span> acceptEventTimeKey;</span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)load &#123;</span><br><span class="line">    Method a = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(sendAction:to:forEvent:));</span><br><span class="line">    Method b = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(__yh_sendAction:to:forEvent:));</span><br><span class="line">    method_exchangeImplementations(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSTimeInterval</span>)acceptEventInterval &#123;</span><br><span class="line">    <span class="keyword">return</span> [objc_getAssociatedObject(<span class="keyword">self</span>, &amp;acceptEventIntervalKey) doubleValue];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)setAcceptEventInterval:(<span class="built_in">NSTimeInterval</span>)acceptEventInterval &#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, &amp;acceptEventIntervalKey, @(acceptEventInterval), OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSTimeInterval</span>)acceptEventTime &#123;</span><br><span class="line">    <span class="keyword">return</span> [objc_getAssociatedObject(<span class="keyword">self</span>, &amp;acceptEventTimeKey) doubleValue];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)setAcceptEventTime:(<span class="built_in">NSTimeInterval</span>)acceptEventTime &#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, &amp;acceptEventTimeKey, @(acceptEventTime), OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)__yh_sendAction:(SEL)action to:(<span class="type">id</span>)target forEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="keyword">if</span> ([[<span class="built_in">NSDate</span> date] timeIntervalSince1970] - <span class="keyword">self</span>.acceptEventTime &lt; <span class="keyword">self</span>.acceptEventInterval) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.acceptEventInterval &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.acceptEventTime = [[<span class="built_in">NSDate</span> date] timeIntervalSince1970];</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span> __yh_sendAction:action to:target forEvent:event];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<h2 id="Runtime的使用"><a href="#Runtime的使用" class="headerlink" title="Runtime的使用"></a>Runtime的使用</h2><p><code>Runtime</code>的使用：获取属性列表，获取成员变量列表，获得方法列表，获取协议列表，方法交换（黑魔法），动态的添加方法，调用私有方法，为分类添加属性。</p>
<h2 id="类在Runtime中的表示"><a href="#类在Runtime中的表示" class="headerlink" title="类在Runtime中的表示"></a>类在<code>Runtime</code>中的表示</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类在runtime中的表示</span></span><br><span class="line"><span class="keyword">struct</span> objc_class &#123;</span><br><span class="line">    Class isa;<span class="comment">//指针，顾名思义，表示是一个什么，</span></span><br><span class="line">    <span class="comment">//实例的isa指向类对象，类对象的isa指向元类</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !__OBJC2__</span></span><br><span class="line">    Class super_class;  <span class="comment">//指向父类</span></span><br><span class="line">    <span class="keyword">const</span> <span class="type">char</span> *name;  <span class="comment">//类名</span></span><br><span class="line">    <span class="type">long</span> version;</span><br><span class="line">    <span class="type">long</span> info;</span><br><span class="line">    <span class="type">long</span> instance_size</span><br><span class="line">    <span class="keyword">struct</span> objc_ivar_list *ivars <span class="comment">//成员变量列表</span></span><br><span class="line">    <span class="keyword">struct</span> objc_method_list **methodLists; <span class="comment">//方法列表</span></span><br><span class="line">    <span class="keyword">struct</span> objc_cache *cache;<span class="comment">//缓存</span></span><br><span class="line">    <span class="comment">//一种优化，调用过的方法存入缓存列表，下次调用先找缓存</span></span><br><span class="line">    <span class="keyword">struct</span> objc_protocol_list *protocols <span class="comment">//协议列表</span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="comment">/* Use `Class` instead of `struct objc_class *` */</span></span><br></pre></td></tr></table></figure>

<h3 id="获取方法-属性等列表"><a href="#获取方法-属性等列表" class="headerlink" title="获取方法&#x2F;属性等列表"></a>获取方法&#x2F;属性等列表</h3><p>有时候会有这样的需求，我们需要知道当前类中每个属性的名字（比如字典转模型，字典的Key和模型对象的属性名字不匹配）。<br>我们可以通过<code>Runtime</code>的一系列方法获取类的一些信息（包括属性列表，方法列表，成员变量列表，和遵循的协议列表）。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> count;</span><br><span class="line">  <span class="comment">//获取属性列表</span></span><br><span class="line">  objc_property_t *propertyList = class_copyPropertyList([<span class="keyword">self</span> <span class="keyword">class</span>], &amp;count);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i=<span class="number">0</span>; i&lt;count; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="type">char</span> *propertyName = property_getName(propertyList[i]);</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@&quot;property----&gt;%@&quot;</span>, [<span class="built_in">NSString</span> stringWithUTF8String:propertyName]);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//获取方法列表</span></span><br><span class="line">  Method *methodList = class_copyMethodList([<span class="keyword">self</span> <span class="keyword">class</span>], &amp;count);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i; i&lt;count; i++) &#123;</span><br><span class="line">      Method method = methodList[i];</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@&quot;method----&gt;%@&quot;</span>, <span class="built_in">NSStringFromSelector</span>(method_getName(method)));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//获取成员变量列表</span></span><br><span class="line">  Ivar *ivarList = class_copyIvarList([<span class="keyword">self</span> <span class="keyword">class</span>], &amp;count);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i; i&lt;count; i++) &#123;</span><br><span class="line">      Ivar myIvar = ivarList[i];</span><br><span class="line">      <span class="keyword">const</span> <span class="type">char</span> *ivarName = ivar_getName(myIvar);</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@&quot;Ivar----&gt;%@&quot;</span>, [<span class="built_in">NSString</span> stringWithUTF8String:ivarName]);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//获取协议列表</span></span><br><span class="line">  __<span class="keyword">unsafe_unretained</span> Protocol **protocolList = class_copyProtocolList([<span class="keyword">self</span> <span class="keyword">class</span>], &amp;count);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i; i&lt;count; i++) &#123;</span><br><span class="line">      Protocol *myProtocal = protocolList[i];</span><br><span class="line">      <span class="keyword">const</span> <span class="type">char</span> *protocolName = protocol_getName(myProtocal);</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@&quot;protocol----&gt;%@&quot;</span>, [<span class="built_in">NSString</span> stringWithUTF8String:protocolName]);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>注意：<code>class_copyPropertyList</code>返回的仅仅是对象类的属性(@property声明的属性)，而<code>class_copyIvarList</code>返回类的所有属性和变量(包括在<code>@interface</code>大括号中声明的变量)</p>
<p>可以另建一个<code>NSObject</code>的分类把这些方法写在分类里面,以后需要的话直接把文件拖进项目里就可以直接使用了</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">XXOOProperty</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取对象的所有属性和属性内容 */</span></span><br><span class="line">- (<span class="built_in">NSDictionary</span> *)getAllPropertiesAndVaules</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *props = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> outCount, i;</span><br><span class="line">    objc_property_t *properties =class_copyPropertyList([<span class="keyword">self</span> <span class="keyword">class</span>], &amp;outCount);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;outCount; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        objc_property_t property = properties[i];</span><br><span class="line">        <span class="keyword">const</span> <span class="type">char</span>* char_f =property_getName(property);</span><br><span class="line">        <span class="built_in">NSString</span> *propertyName = [<span class="built_in">NSString</span> stringWithUTF8String:char_f];</span><br><span class="line">        <span class="type">id</span> propertyValue = [<span class="keyword">self</span> valueForKey:(<span class="built_in">NSString</span> *)propertyName];</span><br><span class="line">        <span class="keyword">if</span> (propertyValue) [props setObject:propertyValue forKey:propertyName];</span><br><span class="line">    &#125;</span><br><span class="line">    free(properties);</span><br><span class="line">    <span class="keyword">return</span> props;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 获取对象的所有属性 */</span></span><br><span class="line">- (<span class="built_in">NSArray</span> *)getAllProperties</span><br><span class="line">&#123;</span><br><span class="line">    u_int count;</span><br><span class="line"></span><br><span class="line">    objc_property_t *properties  =class_copyPropertyList([<span class="keyword">self</span> <span class="keyword">class</span>], &amp;count);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSMutableArray</span> *propertiesArray = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:count];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="type">char</span>* propertyName =property_getName(properties[i]);</span><br><span class="line">        [propertiesArray addObject: [<span class="built_in">NSString</span> stringWithUTF8String: propertyName]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    free(properties);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> propertiesArray;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 获取对象的所有方法 */</span></span><br><span class="line">-(<span class="type">void</span>)getAllMethods</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> mothCout_f =<span class="number">0</span>;</span><br><span class="line">    Method* mothList_f = class_copyMethodList([selfclass],&amp;mothCout_f);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;mothCout_f;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Method temp_f = mothList_f[i];</span><br><span class="line">        IMP imp_f = method_getImplementation(temp_f);</span><br><span class="line">        SEL name_f = method_getName(temp_f);</span><br><span class="line">        <span class="keyword">const</span> <span class="type">char</span>* name_s =sel_getName(method_getName(temp_f));</span><br><span class="line">        <span class="type">int</span> arguments = method_getNumberOfArguments(temp_f);</span><br><span class="line">        <span class="keyword">const</span> <span class="type">char</span>* encoding =method_getTypeEncoding(temp_f);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;方法名：%@,参数个数：%d,编码方式：%@&quot;</span>,[<span class="built_in">NSString</span> stringWithUTF8String:name_s],</span><br><span class="line">              arguments,</span><br><span class="line">              [<span class="built_in">NSString</span> stringWithUTF8String:encoding]);</span><br><span class="line">    &#125;</span><br><span class="line">    free(mothList_f);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>


<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="http://www.jianshu.com/p/d6a68575ce10">Runtime运行时 isa指针 SEL方法选择器 IMP函数指针 Method方法 <code>Runtime</code>消息机制 <code>Runtime</code>的使用</a></li>
<li><a href="http://www.jianshu.com/p/927c8384855a">iOS~Runtime理解 - 简书</a></li>
<li><a href="http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/">Objective-C Runtime | yulingtianxia’s blog</a></li>
<li><a href="https://www.jianshu.com/p/2bf7fedb86b6">iOS - Runtime 方法与消息 - 简书</a></li>
<li><a href="https://tech.meituan.com/DiveIntoMethodCache.html">深入理解Objective-C：方法缓存</a></li>
<li><a href="http://yulingtianxia.com/blog/2016/06/15/Objective-C-Message-Sending-and-Forwarding/">Objective-C 消息发送与转发机制原理</a></li>
</ol>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">MichaelMao</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://michaelmaomao.github.io/2017/12/31/iOS_Runtime/">http://michaelmaomao.github.io/2017/12/31/iOS_Runtime/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://michaelMaoMao.github.io">MMao</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/iOS101/">iOS101</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="https://pic-mike.oss-cn-hongkong.aliyuncs.com/Blog/avatar.png"><div class="post-qr-code__desc">我要吐槽下</div></div></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2018/01/01/iOS_Swift%E5%88%9D%E8%A7%81/"><i class="fa fa-chevron-left">  </i><span>Swift初见</span></a></div><div class="next-post pull-right"><a href="/2017/10/05/iOS_UIScrollView%E5%B5%8C%E5%A5%97%E7%9A%84%E5%B0%9D%E8%AF%95/"><span>UIScrollView嵌套的尝试</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitment-container"></div><script>var gitment = new Gitment({
  owner: 'michaelMaoMao',
  repo: 'michaelMaoMao.github.io',
  oauth: {
    client_id: '98760fb6521b1f01477f',
    client_secret: '88766f6b64e79c5427ddc39db6fa3c42ee19f6d9'
  }
})
gitment.render('gitment-container')</script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2017 - 2025 By MichaelMao</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Hi, this is just a small place for reflect.</div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.6"></script><script src="/js/fancybox.js?version=1.5.6"></script><script src="/js/sidebar.js?version=1.5.6"></script><script src="/js/copy.js?version=1.5.6"></script><script src="/js/fireworks.js?version=1.5.6"></script><script src="/js/transition.js?version=1.5.6"></script><script src="/js/scroll.js?version=1.5.6"></script><script src="/js/head.js?version=1.5.6"></script><script src="/js/search/local-search.js"></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>