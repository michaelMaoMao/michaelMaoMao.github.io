<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Git 笔记系列（七）—— Git常用命令-Rebase"><meta name="keywords" content="Git"><meta name="author" content="MichaelMao"><meta name="copyright" content="MichaelMao"><title>Git 笔记系列（七）—— Git常用命令-Rebase | MMao</title><link rel="shortcut icon" href="/images/my-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.5.6"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.6"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.5.6"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://unpkg.com"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitment/style/default.min.css"><script src="https://cdn.jsdelivr.net/npm/gitment/dist/gitment.browser.min.js"></script><link rel="manifest" href="/manifest.json"><link rel="manifest" href="/manifest.json"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script><meta name="generator" content="Hexo 7.3.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#rebase-%E5%8F%98%E5%9F%BA"><span class="toc-number">1.</span> <span class="toc-text">rebase 变基</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#rebase%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.</span> <span class="toc-text">rebase的定义</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95"><span class="toc-number">2.</span> <span class="toc-text">目录</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#rebase%E8%AF%A6%E8%A7%A3"><span class="toc-number">2.1.</span> <span class="toc-text">rebase详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rebase%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">2.2.</span> <span class="toc-text">rebase的基本操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B"><span class="toc-number">2.3.</span> <span class="toc-text">举例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rebase-%E5%92%8C-merge"><span class="toc-number">2.4.</span> <span class="toc-text">rebase 和 merge</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E8%A7%A3%E5%86%B3%E5%86%B2%E7%AA%81"><span class="toc-number">2.5.</span> <span class="toc-text">二、解决冲突</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E5%86%99%E5%8E%86%E5%8F%B2-git-rebase-i"><span class="toc-number">2.5.1.</span> <span class="toc-text">重写历史 git rebase -i</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rebase%E5%92%8Cmerge%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%91%A2"><span class="toc-number">2.5.2.</span> <span class="toc-text">rebase和merge有什么区别呢</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9Fsum-up%EF%BC%9A-%E6%A0%B8%E5%BF%83%E5%B7%A5%E4%BD%9C%E6%B5%81%E5%8E%9F%E5%88%99%E5%92%8C%E5%BF%83%E6%B3%95"><span class="toc-number">2.6.</span> <span class="toc-text">快速sum up： 核心工作流原则和心法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%81%AA%E6%98%8E%E5%9C%B0merge%E4%B8%80%E4%B8%AAbranch"><span class="toc-number">2.6.1.</span> <span class="toc-text">聪明地merge一个branch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Rebase%E4%B8%80%E4%B8%AA%E5%8F%A4%E8%80%81%E7%9A%84%E5%88%86%E6%94%AF"><span class="toc-number">2.6.2.</span> <span class="toc-text">Rebase一个古老的分支</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8Push%E4%B9%8B%E5%89%8D%E6%B8%85%E7%90%86%E4%BD%A0%E7%9A%84%E6%9C%AC%E5%9C%B0%E5%8E%86%E5%8F%B2"><span class="toc-number">2.6.3.</span> <span class="toc-text">在Push之前清理你的本地历史</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Rebase%E7%9A%84%E6%81%A2%E5%A4%8D"><span class="toc-number">3.</span> <span class="toc-text">Rebase的恢复</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rebase%E7%9A%84%E5%88%87%E6%8D%A2"><span class="toc-number">4.</span> <span class="toc-text">rebase的切换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rebase%E7%9A%84%E9%A3%8E%E9%99%A9"><span class="toc-number">5.</span> <span class="toc-text">rebase的风险</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#rebase%E9%BB%84%E9%87%91%E5%AE%9A%E5%BE%8B"><span class="toc-number">5.1.</span> <span class="toc-text">rebase黄金定律</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rebase%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%E4%BE%8B%E5%AD%90"><span class="toc-number">5.2.</span> <span class="toc-text">rebase正确使用例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rebase%E9%94%99%E8%AF%AF%E4%BD%BF%E7%94%A8%E4%BE%8B%E5%AD%90"><span class="toc-number">5.3.</span> <span class="toc-text">rebase错误使用例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8rebase%E8%A7%A3%E5%86%B3rebase"><span class="toc-number">5.4.</span> <span class="toc-text">用rebase解决rebase</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Rebase%E5%AE%9E%E4%BE%8B"><span class="toc-number">6.</span> <span class="toc-text">Rebase实例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E6%8F%90%E4%BA%A4"><span class="toc-number">7.</span> <span class="toc-text">合并提交</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">8.</span> <span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA"><span class="toc-number">8.1.</span> <span class="toc-text">结论</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-rebase-%E5%92%8C-merge-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99%EF%BC%9A"><span class="toc-number">9.</span> <span class="toc-text">使用 rebase 和 merge 的基本原则：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#git-rebase-%E5%90%88%E5%B9%B6commit"><span class="toc-number">9.1.</span> <span class="toc-text">git rebase 合并commit</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">10.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">11.</span> <span class="toc-text">参考</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://pic-mike.oss-cn-hongkong.aliyuncs.com/Blog/avatar.png"></div><div class="author-info__name text-center">MichaelMao</div><div class="author-info__description text-center">stay on your way</div><div class="follow-button"><a href="https://github.com/FrizzleFur">Follow me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">47</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">24</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="https://juejin.im/user/57f8ffda2e958a005581e3c0/posts">J_Knight</a><a class="author-info-links__name text-center" href="https://halfrost.com/">Halfrost</a><a class="author-info-links__name text-center" href="https://github.com/draveness/analyze">draveness</a><a class="author-info-links__name text-center" href="https://juejin.im/user/5a52075e6fb9a01c9d31b107/posts">老司机周报</a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">MMao</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/ideas">思所</a><a class="site-page" href="/booknotes">读书</a><a class="site-page" href="/about">关于</a><a class="site-page" href="/gallery">相册</a><a class="site-page" href="/gtd">GTD</a></span></div><div id="post-info"><div id="post-title">Git 笔记系列（七）—— Git常用命令-Rebase</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-03-08</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><table>
<thead>
<tr>
<th>时间</th>
<th>更新备注</th>
</tr>
</thead>
<tbody><tr>
<td>2018-03-08</td>
<td>新建文章</td>
</tr>
<tr>
<td>2018-06-09</td>
<td>整理补充</td>
</tr>
<tr>
<td>2019-01-18</td>
<td>更新链接</td>
</tr>
<tr>
<td>2020-08-09</td>
<td>补充</td>
</tr>
</tbody></table>
<h2 id="rebase-变基"><a href="#rebase-变基" class="headerlink" title="rebase 变基"></a>rebase 变基</h2><h3 id="rebase的定义"><a href="#rebase的定义" class="headerlink" title="rebase的定义"></a>rebase的定义</h3><blockquote>
<p>Integrates the changes from the chosen branch<br>into your working copy. Your current HEAD branch<br>will be rebased onto the integrated revisions.</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git-rebase - Reapply commits on top of another base tip</span><br></pre></td></tr></table></figure>

<p>即将当前分支的提交放在其他分支的最新的提交后。但是这个<code>reapply</code>并非简单地将提交剪切复制到，<strong>Rebase 实际上就是取出一系列的提交记录，“复制”它们，然后在另外一个地方逐个的放下去。</strong></p>
<span id="more"></span>

<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="https://michaelmao.co/2018/02/27/Git%20%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%20Git%E7%AE%80%E4%BB%8B/">Git 笔记系列（一）—— Git简介</a></li>
<li><a href="https://michaelmao.co/2018/02/28/Git%20%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%20Git%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/">Git 笔记系列（二）—— Git工作流程</a></li>
<li><a href="https://michaelmao.co/2018/02/28/Git%20%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%20Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-%E4%B8%80%E8%A7%88/">Git 笔记系列（三）—— Git常用命令-一览</a></li>
<li><a href="https://michaelmao.co/2018/02/28/Git%20%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%20Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-Checkout/">Git 笔记系列（四）—— Git常用命令-Checkout</a></li>
<li><a href="https://michaelmao.co/2018/03/01/Git%20%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%20Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-Branch/">Git 笔记系列（五）—— Git常用命令-Branch</a></li>
<li><a href="https://michaelmao.co/2018/03/02/Git%20%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%20Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-Reset/">Git 笔记系列（六）—— Git常用命令-Reset</a></li>
<li><a href="https://michaelmao.co/2018/03/08/Git%20%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94%20Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-Rebase/"><strong>Git 笔记系列（七）—— Git常用命令-Rebase</strong></a></li>
<li><a href="https://michaelmao.co/2018/03/10/Git%20%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97%EF%BC%88%E5%85%AB%EF%BC%89%E2%80%94%E2%80%94%20Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-Stash/">Git 笔记系列（八）—— Git常用命令-Stash等</a></li>
<li><a href="https://michaelmao.co/2018/04/26/Git%20%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97%EF%BC%88%E4%B9%9D%EF%BC%89%E2%80%94%E2%80%94%20Git%E8%BF%9B%E9%98%B6/">Git 笔记系列（九）—— Git进阶</a></li>
</ul>
<h3 id="rebase详解"><a href="#rebase详解" class="headerlink" title="rebase详解"></a>rebase详解</h3><p>在 Git 中整合来自不同分支的修改主要有两种方法：<code>merge</code> 以及 <code>rebase</code>。 在本节中我们将学习什么是“变基”，怎样使用“变基”，并将展示该操作的惊艳之处，以及指出在何种情况下你应避免使用它。</p>
<p><code>git rebase</code>用于把一个分支的修改合并到当前分支。<br>假设你现在基于远程分支”origin”，创建一个叫”mywork”的分支。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b mywork origin</span><br></pre></td></tr></table></figure>
<p>但是与此同时，有些人也在”origin”分支上做了一些修改并且做了提交了. 这就意味着”origin”和”mywork”这两个分支各自”前进”了，它们之间”分叉”了。</p>
<p><img src="http://pic-mike.oss-cn-hongkong.aliyuncs.com/qiniu/15203114694870.jpg"></p>
<p>如果你想让”mywork”分支历史看起来像没有经过任何合并一样，你也许可以用<code>git rebase</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout mywork</span><br><span class="line">$ git rebase origin</span><br></pre></td></tr></table></figure>

<p>这些命令会把你的”mywork”分支里的每个提交(commit)取消掉，并且把它们临时保存为补丁(patch)(这些补丁放到”.git&#x2F;rebase”目录中),然后把”mywork”分支更新 为最新的”origin”分支，最后把保存的这些补丁应用到”mywork”分支上。</p>
<p>你也可以看到以前的提交并没有被销毁。他们根本无法直接访问。如果你还记得，分支只是一个指向提交的指针。因此，如果分支和标签都不指向提交，则这些提交几乎不可能被访问，但这些提交仍然存在。</p>
<p><img src="http://pic-mike.oss-cn-hongkong.aliyuncs.com/qiniu/15192866815450.jpg"></p>
<p>当’mywork’分支更新之后，它会指向这些新创建的提交(commit),而那些老的提交会被丢弃。 如果运行垃圾收集命令(pruning garbage collection), 这些被丢弃的提交就会删除. （请查看 git gc)</p>
<p>以前遇到commit写错总是使用git reset –soft回退到之前的状态，再commit后push -f强推到远程库，能够覆盖掉之前的commit。</p>
<p>现在想想也是很low的做法，git rebase 可以帮你搞定这个问题。</p>
<p>好了，随便提交了几个<br><img src="http://pic-mike.oss-cn-hongkong.aliyuncs.com/qiniu/15178298763331.jpg"></p>
<p>在使用git时，我们通常非常频繁地向repo中做commit，但是我们的commit本身往往是零散的不连续的，比如：</p>
<p>我在不同的topic之间来回切换，这样会导致我的历史中不同topic互相交叉，逻辑上组织混乱；<br>我们可能需要多个连续的commit来解决一个bug；<br>我可能会在commit中写了错别字，后来又做修改；<br>甚至我们在一次提交时纯粹就是因为懒惰的原因，我可能吧很多的变更都放在一个commit中做了提交。<br>上面的各种行为只要是保留在local repo中，这是没有问题的，也是正常的，但是如果为了尊重别人同时也为了自己将来能够返回来我绝对避免将这些杂乱的历史信息push到remote上去。在我push之前，我会使用git rebase -i的命令来清理一下历史。</p>
<h3 id="rebase的基本操作"><a href="#rebase的基本操作" class="headerlink" title="rebase的基本操作"></a>rebase的基本操作</h3><p>回顾之前在 分支的合并 中的一个例子，会看到开发任务分叉到两个不同分支，又各自提交了更新。</p>
<p><img src="http://pic-mike.oss-cn-hongkong.aliyuncs.com/qiniu/15203215969566.png"></p>
<p>整合分支最容易的方法是 merge 命令。 它会把两个分支的最新快照（C3 和 C4）以及二者最近的共同祖先（C2）进行三方合并，合并的结果是生成一个新的快照（并提交）。</p>
<p><img src="http://pic-mike.oss-cn-hongkong.aliyuncs.com/qiniu/15203216153820.png"></p>
<p>其实，还有一种方法：你可以提取在 C4 中引入的补丁和修改，然后在 C3 的基础上应用一次。 在 Git 中，这种操作就叫做 变基。 你可以使用 rebase 命令将提交到某一分支上的所有修改都移至另一分支上，就好像“重新播放”一样。</p>
<p><img src="http://pic-mike.oss-cn-hongkong.aliyuncs.com/qiniu/15203251416822.png"></p>
<p>它的原理是首先找到这两个分支（即当前分支 experiment、变基操作的目标基底分支 master）的最近共同祖先 C2，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件，然后将当前分支指向目标基底 C3, 最后以此将之前另存为临时文件的修改依序应用。（译注：写明了 commit id，以便理解，下同）</p>
<p>此时，C4’ 指向的快照就和上面使用 merge 命令的例子中 C5 指向的快照一模一样了。 这两种整合方法的最终结果没有任何区别，但是变基使得提交历史更加整洁。 你在查看一个经过变基的分支的历史记录时会发现，尽管实际的开发工作是并行的，但它们看上去就像是串行的一样，提交历史是一条直线没有分叉。</p>
<p>一般我们这样做的目的是为了确保在向远程分支推送时能保持提交历史的整洁——例如向某个其他人维护的项目贡献代码时。 在这种情况下，你首先在自己的分支里进行开发，当开发完成时你需要先将你的代码变基到 origin&#x2F;master 上，然后再向主项目提交修改。 这样的话，该项目的维护者就不再需要进行整合工作，只需要快进合并便可。</p>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>两个分支<code>master</code>和<code>bugfix</code>都提交了一些commit,使用rebase变基。</p>
<ol>
<li>切换到<code>bugfix</code>然后将<code>bugfix</code>的提交变基到<code>master</code></li>
</ol>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout bugfix</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git rebase master</span></span><br></pre></td></tr></table></figure>

<p><img src="http://pic-mike.oss-cn-hongkong.aliyuncs.com/qiniu/15285113273242.jpg"><br>现在 bugFix 分支上的工作在 master 的最顶端，同时我们也得到了一个更线性的提交序列。</p>
<p><img src="http://pic-mike.oss-cn-hongkong.aliyuncs.com/qiniu/15285114862099.jpg"></p>
<p>注意，提交记录 C3 依然存在（树上那个半透明的节点），而 C3’ 是我们 Rebase 到 master 分支上的 C3 的副本。</p>
<p>现在<code>master</code>还没有更新，下面咱们就来更新它吧</p>
<ol start="2">
<li>切换到<code>master</code>上，然后rebase变基<code>bugfix</code>分支</li>
</ol>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout master</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git rebase bugfix</span></span><br></pre></td></tr></table></figure>

<p><img src="http://pic-mike.oss-cn-hongkong.aliyuncs.com/qiniu/15285116391342.jpg"></p>
<p>好了！由于 <code>bugFix</code> 继承自 <code>master</code>，所以 Git 只是简单的把 <code>master</code> 分支的引用向前移动了一下而已。</p>
<p><img src="http://pic-mike.oss-cn-hongkong.aliyuncs.com/qiniu/15285116198530.jpg"></p>
<h3 id="rebase-和-merge"><a href="#rebase-和-merge" class="headerlink" title="rebase 和 merge"></a>rebase 和 merge</h3><p>无论是通过rebase，还是通过merge合并，整合的最终结果所指向的快照始终是一样的，只不过提交历史不同罢了。 </p>
<ul>
<li><strong>rebase是将一系列提交按照原有次序依次应用到另一分支上</strong></li>
<li><strong>merge是把最终结果合在一起。</strong></li>
</ul>
<h3 id="二、解决冲突"><a href="#二、解决冲突" class="headerlink" title="二、解决冲突"></a>二、解决冲突</h3><p>在rebase的过程中，也许会出现冲突(conflict). 在这种情况，Git会停止rebase并会让你去解决 冲突；在解决完冲突后，用”git-add”命令去更新这些内容的索引(index), 然后，你无需执行 git-commit,只要执行:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase --continue</span><br></pre></td></tr></table></figure>
<p>这样git会继续应用(apply)余下的补丁。<br>在任何时候，你可以用–abort参数来终止rebase的行动，并且”mywork” 分支会回到rebase开始前的状态。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase --abort</span><br></pre></td></tr></table></figure>

<h4 id="重写历史-git-rebase-i"><a href="#重写历史-git-rebase-i" class="headerlink" title="重写历史 git rebase -i"></a>重写历史 git rebase -i</h4><p>工作中，我们可能不小心写错commit，例如上面那个 “测试 git rebase”我写错了，我想改一改，怎么办呢？</p>
<p>1.（打开terminal）</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i 233d7b3( 这个commit是在我们要修改的commit前一个)</span><br><span class="line"></span><br><span class="line">git rebase -i 233d7b3</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后就进入下面这里：</p>
<p><img src="http://pic-mike.oss-cn-hongkong.aliyuncs.com/qiniu/15178298852746.jpg"></p>
<p>这里就是我们熟悉的vi，按i进入insert模式，</p>
<ul>
<li>pick &#x3D; 要這條 commit ，什麼都不改</li>
<li>reword &#x3D; 要這條 commit ，但要改 commit message</li>
<li>edit &#x3D; 要這條 commit，但要改 commit 的內容</li>
<li>squash &#x3D; 要這條 commit，但要跟前面那條合併，並保留這條的 messages</li>
<li>fixup &#x3D; squash + 只使用前面那條 commit 的 message ，捨棄這條 message</li>
<li>exec &#x3D; 執行一條指令（但我沒用過）</li>
</ul>
<p><a href="https://blog.yorkxin.org/2011/07/29/git-rebase.html">Git-rebase 小筆記 - Yu-Cheng Chuang’s Blog</a></p>
<p>我们是要修改，所以改成</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">reword 345c70f 测试 git rebase</span><br><span class="line"></span><br><span class="line">     esc ： wq 保存退出</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>接著儲存檔案後把檔案關掉（如 vim 的 :wq），就開始執行 rebase 啦，遇到 reword  時會再跳出編輯器，讓你重新輸入 commit message 。這時我把 studetns 改正為 students ，然後就跟平常 commit 一樣，存檔並關掉檔案。</p>
<p><img src="http://pic-mike.oss-cn-hongkong.aliyuncs.com/qiniu/15178298937726.jpg"></p>
<p>i进入insert模式，修改commit内容，esc  ： wq 保存退出。</p>
<p>最后还需要强制push</p>
<p>git push –force</p>
<p>那么我们要如何合并几个commit呢？</p>
<p>和上面类似，我们首先</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i f290515(我们要合并的commit的前一个)</span><br></pre></td></tr></table></figure>

<p><img src="http://pic-mike.oss-cn-hongkong.aliyuncs.com/qiniu/15178299079398.jpg"></p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pick 766f348 dsfdsf</span><br><span class="line"></span><br><span class="line">squash 233d7b3 sdfdsf</span><br><span class="line"></span><br><span class="line">squash 345c70f 测试 git rebase</span><br></pre></td></tr></table></figure>

<p>我们可以这样修改  将后面两个改成<code>squash</code>，就是合并到第一个上去</p>
<p>如果没有冲突就可以看到这个界面<br><img src="http://pic-mike.oss-cn-hongkong.aliyuncs.com/qiniu/15178299134967.jpg"></p>
<p>保存退出</p>
<p>最后<code>git push -f</code></p>
<h4 id="rebase和merge有什么区别呢"><a href="#rebase和merge有什么区别呢" class="headerlink" title="rebase和merge有什么区别呢"></a>rebase和merge有什么区别呢</h4><p><img src="http://pic-mike.oss-cn-hongkong.aliyuncs.com/qiniu/15178300610660.jpg"></p>
<p>现在我们在这个分支做一些修改，然后生成两个提交(commit).</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">修改文件</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">修改文件</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit</span></span><br></pre></td></tr></table></figure>

<p>但是与此同时，有些人也在”origin”分支上做了一些修改并且做了提交了. 这就意味着”origin”和”mywork”这两个分支各自”前进”了，它们之间”分叉”了</p>
<p><img src="http://pic-mike.oss-cn-hongkong.aliyuncs.com/qiniu/15178300701048.jpg"></p>
<p>在这里，你可以用”pull”命令把”origin”分支上的修改拉下来并且和你的修改合并； 结果看起来就像一个新的”合并的提交”(merge commit):<br><img src="http://pic-mike.oss-cn-hongkong.aliyuncs.com/qiniu/15178300745333.jpg"><br>但是，如果你想让”mywork”分支历史看起来像没有经过任何合并一样，你也许可以用 git rebase:</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout mywork</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git rebase origin</span></span><br></pre></td></tr></table></figure>

<p>这些命令会把你的”mywork”分支里的每个提交(commit)取消掉，并且把它们临时 保存为补丁(patch)(这些补丁放到”.git&#x2F;rebase”目录中),然后把”mywork”分支更新 为最新的”origin”分支，最后把保存的这些补丁应用到”mywork”分支上。</p>
<p><img src="http://pic-mike.oss-cn-hongkong.aliyuncs.com/qiniu/15178300786831.jpg"><br><img src="http://pic-mike.oss-cn-hongkong.aliyuncs.com/qiniu/15178301165540.jpg"></p>
<h3 id="快速sum-up：-核心工作流原则和心法"><a href="#快速sum-up：-核心工作流原则和心法" class="headerlink" title="快速sum up： 核心工作流原则和心法"></a>快速sum up： 核心工作流原则和心法</h3><p>下面的几个心法是你在使用git时必须磨砺在心的，在本文的后面，我们将具体说明哪些命令来负责执行这些心法：</p>
<ol>
<li><p>当我需要merge一个临时的本地branch时。。。我确保这个branch不会在版本变更历史图谱中显示，我总是使用一个fast-forward merge策略来merge这类branch，而这往往需要在merge之前做一个rebase;</p>
</li>
<li><p>当我需要merge一个项目组都知道的local branch时。。。我得确保这个branch的信息会在历史图谱中一直展示，我总是执行一个true merge;</p>
</li>
<li><p>当我准备push我的本地工作时。。。我得首先清理我的本地历史信息以便我总是push一些清晰易读有用的功能；</p>
</li>
<li><p>当我的push由于和别人已经发布的工作相冲突而被拒绝时，我总是rebase更新到最新的remote branch以避免用一些无意义的micro-merge来污染历史图谱</p>
</li>
</ol>
<h4 id="聪明地merge一个branch"><a href="#聪明地merge一个branch" class="headerlink" title="聪明地merge一个branch"></a>聪明地merge一个branch</h4><p>前面讲过，你只有在需要合并融入一个分支所提供的所有feature时才做merge。在这时，你需要问你的核心的问题是：这个分支需要在历史图谱中展示吗？</p>
<p>当这个分支代表了一个团队都熟知的一块工作时（比如在项目管理系统中的一个task,一个关联到一个ticket的bugfix,一个user story或者use case的实现，一个项目文档工作等），那么在这种情况下，我们应该将branch的信息永远留存在产品历史图谱中，甚至即使branch本身已经被删除。</p>
<p>否则，如果不代表一个well-known body of work,那么branch本身仅仅是一个技术意义上的实体，我们没有理由将它呈现在产品历史图谱中。我们得使用一个rebase+fast-forward merge来完成merge。</p>
<p>我们来看看上面两种场景分别长什么样：</p>
<p>通过”true merge”来保留历史信息<br>我们假设我们一个乘坐oauth-signin的feature branch,该branch的merge 目标是master.</p>
<p>如果master分支在oauth-signin分支从master创建后又往前走了一些commits（这可能是由于其他的branch已经merge到了master,或者在master上直接做了commit，或者有人在master上cherry-picked了一些commits)，那么这时在master和oauth-signin之间就产生了分叉（也就是说master不可能在不会退的情况下直接到oauth-signin)。在这种情况下，git将会自动地产生一个”true merge”</p>
<p> 这是我们要的也是我们希望的，并不需要任何额外工作。</p>
<p>然而，如果master在oauth-signin创建后并未向前走，后者就是master的直接后代（无分叉），这时GIT默认地在merge时是执行一个fast-forward的merge策略，git并不会创建一个merge commit而是简单地把master分支标签移动到oauth-signin分支tip所指向的commit。这时oauth-sigin分支就变成了一个”透明”的分支了：在历史图谱中无法得知oauth-signin分支的起始位置在哪里，并且一旦这个branch被删除，那么从历史上我们再也无法看到任何关于这个开发分支曾经存在的历史渊源。</p>
<p>这不是我们所想要的，所以我们通过强制git产生一个真正的merge—通过使用–no-ff参数（no fast forward的意思）。</p>
<p>通过fast-forward merge来实现merge的透明<br>这是相反的情况：我们的branch因为没有任何实质语义，所以我们不希望它在历史图谱中存在。我们必须确保merge会使用fast-forward策略。</p>
<p>我们假设我们有一个仅仅为了开发的安全性起了一个local branch命名为quick-fixes,而master仍然是要merge到的目标分支。</p>
<p>如果master在quick-fixes创建之后再也没有往前走，我们知道git会产生一个fast-forward的merge:</p>
<p>另一方面，如果master在quick-fixes创建后又往前走了的话，我们如果直接merge的话git会给我们一个true merge，产生一个merge commit，那么我们的branch就会污染历史图谱，这不是我们想要的。</p>
<p>在这种情况下，我们要做的事调整quick-fixes分支使得它重新成为master分支的直接后代（也就是不再分叉），这样就可以fast-forward merge了。要完成这个目的，我们需要使用git rebase命令。我们希望通过更改quick-fixes分支的base commit，以便它的base commit不再是master的老tip，而是当前的tip(注意tip是随着commit的不断引入而不断往前移动的！）。这个动作会重写quick-fixes分支的历史，由于quick-fixes完全是本地分支，重写历史是无关紧要的。</p>
<p>在这里我们特别要注意这个场景是如何运作的：</p>
<ol>
<li><p>我们有一个分叉过的分支但是我们希望透明化地merge，所以。。。</p>
</li>
<li><p>我们首先变基到master的最新commit;</p>
</li>
<li><p>我们随后到master上，执行merge命令就产生一个fast-forward</p>
</li>
</ol>
<p>注意：我这里额外提醒一下，实际上我们看到上面的word1,word2,word3的commit可能还是不爽，我们在第3.步骤中可以使用git merge quick-fixes –squash，来讲所有的word1,2,3都合并成一个commit;</p>
<p>注意留心merge的一些默认配置<br>如果在练习上面的操作时，你发现git并未如你所愿，你需要检查一下git对于merge的一些默认配置。</p>
<p>比如:branch.master.mergeoptions &#x3D; –no-ff&#x2F;merge.ff&#x3D;false或者branch.master.mergeoptions&#x3D;–ff-only&#x2F;merge.ff&#x3D;only</p>
<h4 id="Rebase一个古老的分支"><a href="#Rebase一个古老的分支" class="headerlink" title="Rebase一个古老的分支"></a>Rebase一个古老的分支</h4><p>有时候你创建一个feature分支开始工作后可能很长时间没有时间再做这个feature开发，当你回来时，你的feature分支就会缺失很多master上的bugfix或者一些其他的feature。在这种个情况下，我们先假设除了你没有其他人在这个分支上工作，那么你可以rebase你的feature分支：</p>
<p>git rebase [basebranch] [topicbranch] 注意这时git rebase的参数顺序，第一个为基分支，第二个为要变基的分支</p>
<p>(master) $ git rebase master better-stats<br>注意：如果那个feature分支已经被push到remote了的话，你必须使用-f参数来push它，以便你覆盖这个分支的commits历史，这时覆盖这个branch历史也无所谓，因为历史的所有commits都已经相应重新生成了！！。（一个分支的历史由分支的起始commit和头tip commit来描述.有一点需要注意：一旦我们做一次rebase后，那么这个分支上的所有commit由于这次变基，其commit HASH都会改变！！）另外需要注意我们只能对private分支做这个rebase并且git push –force操作！！</p>
<h4 id="在Push之前清理你的本地历史"><a href="#在Push之前清理你的本地历史" class="headerlink" title="在Push之前清理你的本地历史"></a>在Push之前清理你的本地历史</h4><p>如果你正确地使用git，相信我们都会频繁地做一些原子commit.我们也要铭记以下警句：不要落入SVN人员的行为模式：commit+push，这是集中式版本控制系统的最常见工作模式：每一个commit都立即push到server上。</p>
<p>事实上，如果那样做的话，你就失去了分布式版本控制系统的灵活性：只要我们没有push，我们就有足够的灵活性。所有我们本地的commits只要没有push都是我们自己的，所以我们有完全的自由来清理这些commit，甚至删除取消某些commits。为什么我们要那么每个commit都频繁地Push从而失去我们应该有的灵活性呢？</p>
<p>在一个git的典型工作流中，你每天可能会产生10到30个commit,但是我们往往可能只会push 2到3次，甚至更少。</p>
<p>再次重申：在push之前，我应该清理我的本地历史。</p>
<p>有很多原因会导致我们的本地历史是混乱的，前面已经提及，但是现在还想再说一遍：</p>
<p>我在不同的topic之间来回切换，这样会导致我的历史中不同topic互相交叉，逻辑上组织混乱；<br>我们可能需要多个连续的commit来解决一个bug；<br>我可能会在commit中写了错别字，后来又做修改；<br>甚至我们在一次提交时纯粹就是因为懒惰的原因，我可能吧很多的变更都放在一个commit中做了提交。<br>这些场景都会导致一个混乱的历史产生，非常难以阅读，难以理解，难以被他人所重用，注意：这里的他人也可能是你自己哦，想想两个月后你再来看这段代码吧。</p>
<p>幸运的是，git给你提供了一个漂亮的方法来不用花什么精力就能理清你的本地历史：</p>
<ol>
<li><p>reorder commits;</p>
</li>
<li><p>squash them together;</p>
</li>
<li><p>split one up(trickier)</p>
</li>
<li><p>remove commits altogether;</p>
</li>
<li><p>rephrase commit messages</p>
</li>
</ol>
<p>interactive rebasing就和普通的rebase很相像，它给你一个个地选择编辑你的commit的机会。</p>
<p>在我们当下rebase -i的情形，rebase操作本身并不会实际的真真实实地变基。rebase -i操作仅仅会重写历史。在每天的工作场景中，可能那个分支已经在你的远端库中存在（也就是说已经发布了），你需要做的是清理自从最近一次git pull之后的所有local commits。假设你正在一个experiment分支。你的命令行可能是这样的：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(experiment) $ git rebase -i origin/experiment</span><br></pre></td></tr></table></figure>

<p>在这里你在rebase你的当前分支（experiment分支)到一个已经存在历史中的commit(origin&#x2F;experiment).如果这个rebase不是interactive的话，那么这个动作是毫无意义的（实际上会被作为一个短路的no-op).但是正是有了这个-i选项，你将可以编辑rebase将要执行的这个脚本化过程。那个脚本将会打开一个git editor,就像我们在commit提交时弹出的编辑框一样。</p>
<h2 id="Rebase的恢复"><a href="#Rebase的恢复" class="headerlink" title="Rebase的恢复"></a>Rebase的恢复</h2><ol>
<li>使用reflog查看命令</li>
</ol>
<p><img src="http://pic-mike.oss-cn-hongkong.aliyuncs.com/qiniu/15387150696176.jpg"></p>
<ul>
<li>找到rebase之前的hash</li>
<li>reset hash –hard</li>
</ul>
<ol>
<li>使用<code>ORIG_HEAD</code><br>ORIG_HEAD会保存上一次比较危险的rebase操作之前的的HEAD。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset ORIG_HEAD --hard</span><br></pre></td></tr></table></figure>


<h2 id="rebase的切换"><a href="#rebase的切换" class="headerlink" title="rebase的切换"></a>rebase的切换</h2><p>在对两个分支进行变基时，所生成的“重放”并不一定要在目标分支上应用，你也可以指定另外的一个分支进行应用。 就像 从一个特性分支里再分出一个特性分支的提交历史 中的例子那样。 你创建了一个特性分支 server，为服务端添加了一些功能，提交了 C3 和 C4。 然后从 C3 上创建了特性分支 client，为客户端添加了一些功能，提交了 C8 和 C9。 最后，你回到 server 分支，又提交了 C10。</p>
<p><img src="http://pic-mike.oss-cn-hongkong.aliyuncs.com/qiniu/15203253826791.png"></p>
<p>假设你希望将 client 中的修改合并到主分支并发布，但暂时并不想合并 server 中的修改，因为它们还需要经过更全面的测试。 这时，你就可以使用 git rebase 命令的 –onto 选项，选中在 client 分支里但不在 server 分支里的修改（即 C8 和 C9），将它们在 master 分支上重放：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git rebase --onto master server client</span></span><br></pre></td></tr></table></figure>

<p>以上命令的意思是：“取出 client 分支，找出处于 client 分支和 server 分支的共同祖先之后的修改，然后把它们在 master 分支上重放一遍”。 这理解起来有一点复杂，不过效果非常酷。</p>
<p>现在可以快进合并 master 分支了。（如图 快进合并 master 分支，使之包含来自 client 分支的修改）：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout master</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge client</span></span><br></pre></td></tr></table></figure>
<p><img src="http://pic-mike.oss-cn-hongkong.aliyuncs.com/qiniu/15203254706437.png"></p>
<p>接下来你决定将 server 分支中的修改也整合进来。 使用 git rebase [basebranch] [topicbranch] 命令可以直接将特性分支（即本例中的 server）变基到目标分支（即 master）上。这样做能省去你先切换到 server 分支，再对其执行变基命令的多个步骤。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase master server</span><br></pre></td></tr></table></figure>

<p>如图 将 server 中的修改变基到 master 上 所示，server 中的代码被“续”到了 master 后面。<br><img src="http://pic-mike.oss-cn-hongkong.aliyuncs.com/qiniu/15203255477506.png"></p>
<h2 id="rebase的风险"><a href="#rebase的风险" class="headerlink" title="rebase的风险"></a>rebase的风险</h2><p><img src="http://pic-mike.oss-cn-hongkong.aliyuncs.com/qiniu/15385903195845.jpg"></p>
<p>因为在rebase 公共分支的时候，团队其他成员可能会已经提交，造成rebase修改历史之后，push推送到远端的时候，造成冲突，分支错乱。</p>
<h3 id="rebase黄金定律"><a href="#rebase黄金定律" class="headerlink" title="rebase黄金定律"></a>rebase黄金定律</h3><p><strong>不要对在你的仓库外有副本的分支（共享分支）执行变基。</strong><br><strong>不要对已经推出去的内容进行修改历史</strong></p>
<ul>
<li>共享分支，我的意思是存在于远端存储库中的分支以及您团队中的其他人员可以进行分支。</li>
</ul>
<p><em>rebase操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交</em>。 如果你已经将提交推送至某个仓库，而其他人也已经从该仓库拉取提交并进行了后续工作，此时，如果你用 <code>git rebase</code> 命令重新整理了提交并再次推送，你的同伴因此将不得不再次将他们手头的工作与你的提交进行整合，如果接下来你还要拉取并整合他们修改过的提交，事情就会变得一团糟。</p>
<p>永远不要rebase一个已经分享的分支（到非remote分支，比如rebase到master,develop,release分支上），也就是说永远不要rebase一个已经在中央库中存在的分支.<strong>只能rebase你自己使用的私有分支</strong></p>
<h3 id="rebase正确使用例子"><a href="#rebase正确使用例子" class="headerlink" title="rebase正确使用例子"></a>rebase正确使用例子</h3><ul>
<li>下游分支更新上游分支内容的时候使用 rebase，方便去除无意义的merge commit</li>
</ul>
<p>如你和你的同事John都工作在一个feature开发上，你和他分别做了一些commit，随后你fetch了John的feature分支（或者已经被John分享到中央库的feature分支），那么你的repo的版本历史可能已经是下面的样子了：<br><img src="http://pic-mike.oss-cn-hongkong.aliyuncs.com/qiniu/15178302903450.jpg"></p>
<p>这时你希望集成John的feature开发工作，你也有两个选择，要么merge,要么rebase,<br><img src="http://pic-mike.oss-cn-hongkong.aliyuncs.com/qiniu/15178302864675.jpg"></p>
<p>记住在这个场景中，你rebase到John&#x2F;feature分支的操作并不违反rebase的黄金定律，因为：</p>
<p>只有你的local本地私有（还未push的） <code>feature commits</code>被移动和重写历史了，而你的本地commit之前的所有commit都未做改变。这就像是说“把我的改动放到John的工作之上”。在大多数情况下，这种rebase比用merge要好很多</p>
<h3 id="rebase错误使用例子"><a href="#rebase错误使用例子" class="headerlink" title="rebase错误使用例子"></a>rebase错误使用例子</h3><p><a href="https://segmentfault.com/a/1190000005937408">Git Rebase原理以及黄金准则详解 - 某熊的全栈之路 - SegmentFault 思否</a></p>
<p><img src="https://segmentfault.com/img/remote/1460000005937411"></p>
<p>相信对于rebase肯定不会陌生，就好像上图描述的过程一样，当你使用rebase命令的时候，即好像将你需要去rebase的分支拔下来然后重新插到另一个分支上。官方对于rebase的描述为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">“git-rebase: Forward-port local commits to the updated upstream head”— git doc</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>翻译一下，就是讲你在某个分支上的所有提交记录移花接木到另一个分支上。这边需要强调一个概念：reapply，使用rebase并不是简单地好像你用ctrl-x&#x2F;ctrl-v进行剪切复制一样，rebase会依次地将你所要操作的分支的所有提交应用到目标分支上。也就是说，实际上在执行rebase的时候，有两个隐含的注意点：</p>
<ul>
<li><p>在重放之前的提交的时候，Git会创建新的提交，也就是说即使你重放的提交与之前的一模一样Git也会将之当做新的独立的提交进行处理。</p>
</li>
<li><p>Git rebase并不会删除老的提交，也就是说你在对某个分支执行了rebase操作之后，老的提交仍然会存放在.git文件夹的objects目录下。如果你对于Git是如何存放你的提交不太了解的话可以参考这篇文章：<a href="https://medium.freecodecamp.com/understanding-git-for-real-by-exploring-the-git-directory-1e079c15b807#.6ylqa5e2w">Understanding git for real by exploring the .git directory</a></p>
</li>
</ul>
<p>基于以上表述，我们可以得出以下相对更准确的Git rebase的工作流程：</p>
<p><img src="https://segmentfault.com/img/remote/1460000005937418"></p>
<p>从上图可以看出，在对特征分支进行rebase之后，其等效于创建了新的提交。并且老的提交也没有被销毁，只是简单地不能再被访问或者使用。在对于分支的章节我们曾经提及，一个分支只是一个执行提交的指针。因此如果既没有分支或者Tag指向某个提交，该提交将无法再被访问使用，但是该提交会一直存在于你的文件系统中，占用着你的磁盘存储。</p>
<blockquote>
<p>“No one shall rebase a shared branch” — Everyone about rebase</p>
</blockquote>
<p>估计你也肯定看过这个原则，不过可能表述不一样罢了。本章节就是用实例的角度来探讨下，为啥不能再一个共享的分支上进行Git rebase操作。所谓共享的分支，即是指那些存在于远端并且允许团队中的其他人进行Pull操作的分支。假设现在Bob和Anna在同一个项目组中工作，项目所属的仓库和分支大概是下图这样：</p>
<p><img src="https://segmentfault.com/img/remote/1460000005937420"></p>
<p>现在Bob为了图一时方便打破了原则，正巧这时Anna在特征分支上进行了新的提交，此时的结构图大概是这样的：</p>
<p><img src="https://segmentfault.com/img/remote/1460000005937424"></p>
<p>当Bob打算推送自己的分支到远端的时候，它收到了如下的警告：</p>
<p><img src="https://segmentfault.com/img/remote/1460000005937422"></p>
<p>Git尝试着使用fast-forward来合并你的分支，具体的细节我们会在其他博客中进行讨论，这边只需要明白远端的Git Server被Bob搞得一头雾水，不知道应该如何去合并。此时Bob为了推送他的本地的提交，只能选择强行合并，即告诉远端：不要再尝试着合并我推送给你的和你已经有点提交，一切按照我推送过去的来。那么Git会进行如下操作：</p>
<p><img src="https://segmentfault.com/img/remote/1460000005937426"></p>
<p>然后呢，当Anna也进行推送的时候，她会得到如下的提醒：</p>
<p><img src="https://segmentfault.com/img/remote/1460000005937428"></p>
<p>这个消息很正常，没啥特殊的，只是Git提醒Anna她本地的版本与远程分支并不一致，在Anna提交之前，分支中的Commit序列是如下这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">A--B--C--D&#x27;   origin/feature // GitHub</span><br><span class="line"></span><br><span class="line">A--B--D--E    feature        // Anna</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在进行Pull操作之后，Git会进行自动地合并操作，结果大概是这样的：</p>
<p><img src="https://segmentfault.com/img/remote/1460000005937430"></p>
<p>这个第M个提交即代表着合并的提交，也就是Anna本地的分支与Github上的特征分支最终合并的点，现在Anna解决了所有的合并冲突并且可以Push她的代码，在Bob进行Pull之后，每个人的Git Commit结构为：</p>
<p><img src="https://segmentfault.com/img/remote/1460000005937432"></p>
<p>到这里，看到上面这个混乱的流线图，相信你对于Rebase和所谓的黄金准则也有了更形象深入的理解。这还只是仅有两个人，一个特征分支的项目因为误用rebase产生的后果。如果你团队中的每个人都对公共分支进行rebase操作，那还不得一团乱麻。另外，相信你也注意到，在远端的仓库中存有大量的重复的Commit信息，这会大大浪费我们的存储空间。如果你还觉得这么什么，那我们来假设下还有一哥们Emma，第三个开发人员，在他进行了本地Commit并且Push到远端之后，仓库变为了：</p>
<p><img src="https://segmentfault.com/img/remote/1460000005937489"></p>
<p>在执行git rebase之前，总是多问问你自己：“有没有其他人也需要这个分支来工作？”，如果答案是yes，那么你就需要思考必须使用一种非破坏性的方式来完成rebase一样的工作（就是需要合入别人的工作成果），比如使用git revert命令。否则，如果这个branch没有别人来使用，那么很好，你可以非常安全地随心所欲地re-write history（注意rebase往往会重写历史，所有已经存在的commits虽然内容没有改变，但是commit本身的hash都会改变!!!）</p>
<h3 id="用rebase解决rebase"><a href="#用rebase解决rebase" class="headerlink" title="用rebase解决rebase"></a>用rebase解决rebase</h3><p>在本例中另一种简单的方法是使用 git pull –rebase 命令而不是直接 git pull。 又或者你可以自己手动完成这个过程，先 <code>git fetch</code>，再 <code>git rebase teamone/master</code>。</p>
<h2 id="Rebase实例"><a href="#Rebase实例" class="headerlink" title="Rebase实例"></a>Rebase实例</h2><p><img src="http://pic-mike.oss-cn-hongkong.aliyuncs.com/qiniu/15387162622719.jpg"></p>
<p>rebase生成新的节点，包含变基后的所有改动。</p>
<p><img src="http://pic-mike.oss-cn-hongkong.aliyuncs.com/qiniu/15387164945050.jpg"></p>
<h2 id="合并提交"><a href="#合并提交" class="headerlink" title="合并提交"></a>合并提交</h2><p>我为什么要写这篇文章呢？因为实在太多同学跑来问我「<strong>到底怎么合并 commit？</strong>」了，每次都重复讲一遍这种做法完全不符合程序猿的风格啊！</p>
<p>那么，就先让我们来看这么一个情况，我们执行以下命令获得四个 Commit：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mkdir test</span><br><span class="line">cd test</span><br><span class="line"></span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line">echo &quot;0&quot; &gt;&gt; a</span><br><span class="line">git add a</span><br><span class="line">git commit -m &quot;Commit-0&quot;</span><br><span class="line"></span><br><span class="line">echo &quot;1&quot; &gt;&gt; a</span><br><span class="line">git add a</span><br><span class="line">git commit -m &quot;Commit-1&quot;</span><br><span class="line"></span><br><span class="line">echo &quot;2&quot; &gt;&gt; a</span><br><span class="line">git add a</span><br><span class="line">git commit -m &quot;Commit-2&quot;</span><br><span class="line"></span><br><span class="line">echo &quot;3&quot; &gt;&gt; a</span><br><span class="line">git add a</span><br><span class="line">git commit -m &quot;Commit-3&quot;</span><br></pre></td></tr></table></figure>

<p>我们可以看到 Git 的历史长成这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* b1b8189 - (HEAD -&gt; master) Commit-3</span><br><span class="line">* 5756e15 - Commit-2</span><br><span class="line">* e7ba81d - Commit-1</span><br><span class="line">* 5d39ff2 - Commit-0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>那么问题来了，如何把 <code>e7ba81d(Commit-1)</code>、<code>5756e15(Commit-2)</code>、<code>b1b8189(Commit-3)</code> 合并到一起，并且只保留 <code>e7ba81d(Commit-1)</code> 的 Git message <code>Commit-1</code> 呢？</p>
<p>这个时候我们就要祭出我们这篇文章的主角—— <code>git rebase -i</code> 了！<br><em>这里我不想直接搬出写文档的那套，把所有的选项都介绍完，我们就把这次要用到的讲一下。</em></p>
<p><code>-i</code> 实际上就是 <code>--interactive</code> 的简写，在使用 <code>git rebase -i</code> 时，我们要在后面再添加一个参数，这个参数应该是 <strong>最新的一个想保留的 Commit</strong>。这句话读起来有点坳口，所以这个情况下通常需要举个例子。就我们前面提到的那个例子中，这个「最新的一个想保留的 Commit」就是 <code>5d39ff2(Commit-0)</code>，于是我们的命令看起来就长这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i 5d39ff2</span><br></pre></td></tr></table></figure>

<p>当然，我们也可以通过 <code>HEAD~3</code> 来指定该 Commit：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i HEAD~3</span><br></pre></td></tr></table></figure>

<p>按下回车后，我们会进入到这么一个界面：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">pick e7ba81d Commit-1</span><br><span class="line">pick 5756e15 Commit-2</span><br><span class="line">pick b1b8189 Commit-3</span><br><span class="line"></span><br><span class="line"># Rebase 5d39ff2..b1b8189 onto 5d39ff2 (3 command(s))</span><br><span class="line">#</span><br><span class="line"># Commands:</span><br><span class="line"># p, pick = use commit</span><br><span class="line"># r, reword = use commit, but edit the commit message</span><br><span class="line"># e, edit = use commit, but stop for amending</span><br><span class="line"># s, squash = use commit, but meld into previous commit</span><br><span class="line"># f, fixup = like &quot;squash&quot;, but discard this commit&#x27;s log message</span><br><span class="line"># x, exec = run command (the rest of the line) using shell</span><br><span class="line">#</span><br><span class="line"># These lines can be re-ordered; they are executed from top to bottom.</span><br><span class="line">#</span><br><span class="line"># If you remove a line here THAT COMMIT WILL BE LOST.</span><br><span class="line">#</span><br><span class="line"># However, if you remove everything, the rebase will be aborted.</span><br><span class="line">#</span><br><span class="line"># Note that empty commits are commented out</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>前面三行是我们需要操作的三个 Commit，每行最前面的是对该 Commit 操作的 Command。关于每个 Command 具体做什么，下面的注释写得非常清楚。为了完成我们的需求，我们可以关注到这两个命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s, squash = use commit, but meld into previous commit</span><br><span class="line">f, fixup = like &quot;squash&quot;, but discard this commit&#x27;s log message</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>为了让大家看得更明白，我不厌其烦地翻译一下：</p>
<ul>
<li><code>squash</code>：使用该 Commit，但会被合并到前一个 Commit 当中</li>
<li><code>fixup</code>：就像 <code>squash</code> 那样，但会抛弃这个 Commit 的 Commit message</li>
</ul>
<p>看样子两个命令都可以完成我们的需求，那么让我们先试一下 <code>squash</code>！由于我们是想把三个 Commit 都合并在一起，并且使 Commit Message 写成 <code>Commit-1</code>，所以我们需要把 <code>5756e15(Commit-2)</code> 和 <code>b1b8189(Commit-3)</code> 前面的 <code>pick</code> 都改为<code>squash</code>，于是它看起来像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pick e7ba81d Commit-1</span><br><span class="line">squash 5756e15 Commit-2</span><br><span class="line">squash b1b8189 Commit-3</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当然，因为我很懒，所以通常我会使用它的缩写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pick e7ba81d Commit-1</span><br><span class="line">s 5756e15 Commit-2</span><br><span class="line">s b1b8189 Commit-3</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>完成后，使用 <code>:wq</code> 保存并退出。这个时候，我们进入到了下一个界面：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># This is a combination of 3 commits.</span><br><span class="line"># The first commit&#x27;s message is:</span><br><span class="line">Commit-1</span><br><span class="line"></span><br><span class="line"># This is the 2nd commit message:</span><br><span class="line"></span><br><span class="line">Commit-2</span><br><span class="line"></span><br><span class="line"># This is the 3rd commit message:</span><br><span class="line"></span><br><span class="line">Commit-3</span><br><span class="line"></span><br><span class="line"># Please enter the commit message for your changes. Lines starting</span><br><span class="line"># with &#x27;#&#x27; will be ignored, and an empty message aborts the commit.</span><br><span class="line">#</span><br><span class="line"># Date:      Tue Jan 5 23:27:22 2016 +0800</span><br><span class="line">#</span><br><span class="line"># rebase in progress; onto 5d39ff2</span><br><span class="line"># You are currently editing a commit while rebasing branch &#x27;master&#x27; on &#x27;5d39ff2&#x27;.</span><br><span class="line">#</span><br><span class="line"># Changes to be committed:</span><br><span class="line">#   modified:   a</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过下面的注释，我们可以知道，这里其实就是一个编写 Commit Message 的界面，带 <code>#</code> 的行会被忽略掉，其余的行就会作为我们的新 Commit Message。为了完成我们的需求，我们修改成这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Commit-1</span><br><span class="line"></span><br><span class="line"># Please enter the commit message for your changes. Lines starting</span><br><span class="line"># with &#x27;#&#x27; will be ignored, and an empty message aborts the commit.</span><br><span class="line">#</span><br><span class="line"># Date:      Tue Jan 5 23:27:22 2016 +0800</span><br><span class="line">#</span><br><span class="line"># rebase in progress; onto 5d39ff2</span><br><span class="line"># You are currently editing a commit while rebasing branch &#x27;master&#x27; on &#x27;5d39ff2&#x27;.</span><br><span class="line">#</span><br><span class="line"># Changes to be committed:</span><br><span class="line">#   modified:   a</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用 <code>:wq</code> 后，再看一下我们的 log：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 2d7b687 - (HEAD -&gt; master) Commit-1</span><br><span class="line">* 5d39ff2 - Commit-0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>任务完成！</p>
<hr>
<p>至于 <code>fixup</code> 怎么用，我觉得大家现在应该已经知道了，因为我已经展示过 <code>squash</code> 的用法了，相信你再去看一下上面的 <code>fixup</code> 的解释就能明白了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p>rebase最大的好处是你的项目历史会非常整洁。首先，它不像 git merge 那样引入不必要的合并提交。其次，如上图所示，rebase 导致最后的项目历史呈现出完美的线性——你可以从项目终点到起点浏览而不需要任何的 fork。这让你更容易使用 git log、git bisect 和 gitk 来查看项目历史。</p>
</li>
<li><p>不过，这种简单的提交历史会带来两个后果：安全性和可跟踪性。如果你违反了 rebase 黄金法则，重写项目历史可能会给你的协作工作流带来灾难性的影响。此外，rebase 不会有合并提交中附带的信息——你看不到 feature 分支中并入了上游的哪些更改。</p>
</li>
<li><p>现在，让我们回到之前的问题上来，到底合并还是变基好？希望你能明白，这并没有一个简单的答案。 Git 是一个非常强大的工具，它允许你对提交历史做许多事情，但每个团队、每个项目对此的需求并不相同。 既然你已经分别学习了两者的用法，相信你能够根据实际情况作出明智的选择。</p>
</li>
<li><p>总的原则是，只对尚未推送或分享给别人的<strong>本地修改</strong>执行变基操作清理历史，从不对已推送至别处的提交执行变基操作**，这样，你才能享受到两种方式带来的便利。</p>
</li>
<li><p>一句话，私有的用rebase，公开的用merge。</p>
</li>
</ul>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul>
<li>一句话，私有的用rebase，公开的用merge。</li>
<li>只要你的分支上需要rebase的所有commits历史还没有被push过(比如上例中rebase时从分叉处开始有两个commit历史会被重写)，就可以安全地使用git rebase来操作。</li>
<li>上述结论可能还需要修正：对于不再有子分支的branch，并且因为rebase而会被重写的commits都还没有push分享过，可以比较安全地做rebase</li>
<li>我们在rebase自己的私有分支后希望push到中央库中，但是却会由于rebase改写了历史，因此push时肯定会存在冲突，从而git拒绝你的push，这时，你可以安全地使用-f参数来覆盖中央库的历史（同时其他对这个feature也使用的人员可以git pull）:</li>
</ul>
<h2 id="使用-rebase-和-merge-的基本原则："><a href="#使用-rebase-和-merge-的基本原则：" class="headerlink" title="使用 rebase 和 merge 的基本原则："></a>使用 rebase 和 merge 的基本原则：</h2><ul>
<li>下游分支更新上游分支内容的时候使用 rebase</li>
<li>上游分支合并下游分支内容的时候使用 merge</li>
<li>更新当前分支的内容时一定要使用 –rebase 参数</li>
<li>例如现有上游分支 master，基于 master 分支拉出来一个开发分支 dev，在 dev 上开发了一段时间后要把 master 分支提交的新内容更新到 dev 分支，此时切换到 dev 分支，使用 git rebase master</li>
<li>等 dev 分支开发完成了之后，要合并到上游分支 master 上的时候，切换到 master 分支，使用 git merge dev</li>
</ul>
<p>用rebase：</p>
<ul>
<li>一个人工作</li>
<li>私有分支</li>
<li>本地内容</li>
</ul>
<p>用merge</p>
<ul>
<li>多人协作</li>
<li>公开分支</li>
<li>公开内容</li>
</ul>
<h3 id="git-rebase-合并commit"><a href="#git-rebase-合并commit" class="headerlink" title="git rebase 合并commit"></a>git rebase 合并commit</h3><ul>
<li>当我们在本地仓库中提交了多次，在我们把本地提交push到公共仓库中之前，为了让提交记录更简洁明了，我们希望把如下分支B、C、D三个提交记录合并为一个完整的提交，然后再push到公共仓库。</li>
<li>git rebase -i 合并commit 肯定修改了git历史，所以需要强推，但在公共分支上会有风险。永远不要在已经push了的commit上使用。</li>
</ul>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>rebase操作过程是把本地提交一次一个地迁移到更新了的中央仓库master分支之上。 这意味着可能要解决在迁移某个提交时出现的合并冲突，而不是解决包含了所有提交的大型合并时所出现的冲突。 这样的方式让你尽可能保持每个提交的聚焦和项目历史的整洁。反过来，简化了哪里引入Bug的分析，如果有必要，回滚修改也可以做到对项目影响最小。</p>
<p>[translations&#x2F;workflow-centralized.md at master](<a href="https://github.com/oldratlee/translations/blob/master/git-workflows-and-tutorials/">https://github.com/oldratlee/translations/blob/master/git-workflows-and-tutorials/</a><br>workflow-centralized.md)</p>
<p>git pull –rebase</p>
<p>如果你忘加了这个选项，pull操作仍然可以完成，但每次pull操作要同步中央仓库中别人修改时，提交历史会以一个多余的『合并提交』结尾。 对于集中式工作流，最好是使用rebase而不是生成一个合并提交。</p>
<p>–rebase选项告诉Git把小红的提交移到同步了中央仓库修改后的master分支的顶部，如下图所示：<br><img src="https://pic-mike.oss-cn-hongkong.aliyuncs.com/Blog/20200809171806.png"></p>
<p>如果你忘加了这个选项，pull操作仍然可以完成，但每次pull操作要同步中央仓库中别人修改时，提交历史会以一个多余的『合并提交』结尾。 对于集中式工作流，最好是使用rebase而不是生成一个合并提交。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA#rrbdiag_g">Git - 变基</a></li>
<li><a href="https://git-scm.com/docs/git-rebase">git-rebase</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/34197548">GIT使用rebase和merge的正确姿势 - 知乎</a></li>
<li><a href="https://github.com/geeeeeeeeek/git-recipes/wiki/5.1-%E4%BB%A3%E7%A0%81%E5%90%88%E5%B9%B6%EF%BC%9AMerge%E3%80%81Rebase-%E7%9A%84%E9%80%89%E6%8B%A9">5.1 代码合并：Merge、Rebase 的选择 · geeeeeeeeek&#x2F;git-recipes Wiki</a></li>
<li><a href="https://www.jianshu.com/p/cca69cb695a6">git rebase使用笔记</a></li>
<li><a href="https://medium.freecodecamp.org/git-rebase-and-the-golden-rule-explained-70715eccc372">Git rebase and the golden rule explained.</a></li>
<li><a href="https://www.jianshu.com/p/384a945f6e7e">用了两年git，rebase原来这样用 - 简书</a></li>
<li><a href="https://github.com/Jisuanke/tech-exp/issues/13">如何优雅地合并多个 Commit · Issue #13 · Jisuanke&#x2F;tech-exp</a></li>
</ol>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">MichaelMao</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://michaelmaomao.github.io/2018/03/08/Git%20%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94%20Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-Rebase/">http://michaelmaomao.github.io/2018/03/08/Git%20%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94%20Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-Rebase/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://michaelMaoMao.github.io">MMao</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Git/">Git</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="https://pic-mike.oss-cn-hongkong.aliyuncs.com/Blog/avatar.png"><div class="post-qr-code__desc">我要吐槽下</div></div></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2018/03/10/Git%20%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97%EF%BC%88%E5%85%AB%EF%BC%89%E2%80%94%E2%80%94%20Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-Stash/"><i class="fa fa-chevron-left">  </i><span>Git 笔记系列（八）—— Git常用命令-Stash</span></a></div><div class="next-post pull-right"><a href="/2018/03/02/Git%20%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%20Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-Reset/"><span>Git 笔记系列（六）—— Git常用命令-Reset</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitment-container"></div><script>var gitment = new Gitment({
  owner: 'michaelMaoMao',
  repo: 'michaelMaoMao.github.io',
  oauth: {
    client_id: '98760fb6521b1f01477f',
    client_secret: '88766f6b64e79c5427ddc39db6fa3c42ee19f6d9'
  }
})
gitment.render('gitment-container')</script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2017 - 2025 By MichaelMao</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Hi, this is just a small place for reflect.</div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.6"></script><script src="/js/fancybox.js?version=1.5.6"></script><script src="/js/sidebar.js?version=1.5.6"></script><script src="/js/copy.js?version=1.5.6"></script><script src="/js/fireworks.js?version=1.5.6"></script><script src="/js/transition.js?version=1.5.6"></script><script src="/js/scroll.js?version=1.5.6"></script><script src="/js/head.js?version=1.5.6"></script><script src="/js/search/local-search.js"></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>