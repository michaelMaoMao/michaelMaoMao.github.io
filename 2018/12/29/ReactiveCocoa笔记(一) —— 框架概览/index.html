<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="ReactiveCocoa笔记(一）—— 框架概览"><meta name="keywords" content="ReactiveCocoa"><meta name="author" content="MichaelMao"><meta name="copyright" content="MichaelMao"><title>ReactiveCocoa笔记(一）—— 框架概览 | MMao</title><link rel="shortcut icon" href="/images/my-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.5.6"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.6"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.5.6"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://unpkg.com"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitment/style/default.min.css"><script src="https://cdn.jsdelivr.net/npm/gitment/dist/gitment.browser.min.js"></script><link rel="manifest" href="/manifest.json"><link rel="manifest" href="/manifest.json"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script><meta name="generator" content="Hexo 7.3.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#ReactiveCocoa%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.</span> <span class="toc-text">ReactiveCocoa解决的问题:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ReactiveCocoa-%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">2.</span> <span class="toc-text">ReactiveCocoa 的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ReactiveCocoa-%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">3.</span> <span class="toc-text">ReactiveCocoa 的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E5%9B%BE%E7%A4%BA"><span class="toc-number">4.</span> <span class="toc-text">总结图示</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFReactiveCocoa%EF%BC%9F"><span class="toc-number">4.1.</span> <span class="toc-text">什么是ReactiveCocoa？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ReactiveCocoa-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-number">5.</span> <span class="toc-text">ReactiveCocoa 源码解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90%E4%BB%A3%E7%A0%81"><span class="toc-number">5.1.</span> <span class="toc-text">例子代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RACSignal"><span class="toc-number">6.</span> <span class="toc-text">RACSignal</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RACSubject"><span class="toc-number">7.</span> <span class="toc-text">RACSubject</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%96%B9%E6%B3%95"><span class="toc-number">7.0.1.</span> <span class="toc-text">创建方法:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">7.0.2.</span> <span class="toc-text">工作流程:</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RACSequence"><span class="toc-number">8.</span> <span class="toc-text">RACSequence</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RACStream"><span class="toc-number">9.</span> <span class="toc-text">RACStream</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RACSubject%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">10.</span> <span class="toc-text">RACSubject的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RAC%E8%B0%83%E8%AF%95"><span class="toc-number">10.1.</span> <span class="toc-text">RAC调试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RACCommand"><span class="toc-number">11.</span> <span class="toc-text">RACCommand</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">12.</span> <span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E6%80%BB%E7%BB%93"><span class="toc-number">12.1.</span> <span class="toc-text">信号总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RAC%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">12.2.</span> <span class="toc-text">RAC的作用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">13.</span> <span class="toc-text">参考</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://pic-mike.oss-cn-hongkong.aliyuncs.com/Blog/avatar.png"></div><div class="author-info__name text-center">MichaelMao</div><div class="author-info__description text-center">stay on your way</div><div class="follow-button"><a href="https://github.com/FrizzleFur">Follow me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">40</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">14</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="https://juejin.im/user/57f8ffda2e958a005581e3c0/posts">J_Knight</a><a class="author-info-links__name text-center" href="https://halfrost.com/">Halfrost</a><a class="author-info-links__name text-center" href="https://github.com/draveness/analyze">draveness</a><a class="author-info-links__name text-center" href="https://juejin.im/user/5a52075e6fb9a01c9d31b107/posts">老司机周报</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://pic-mike.oss-cn-hongkong.aliyuncs.com/Blog/20190218170255.png)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">MMao</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/ideas">思所</a><a class="site-page" href="/booknotes">读书</a><a class="site-page" href="/about">关于</a><a class="site-page" href="/gallery">相册</a><a class="site-page" href="/gtd">GTD</a></span></div><div id="post-info"><div id="post-title">ReactiveCocoa笔记(一）—— 框架概览</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-12-29</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><blockquote>
<p>对于一个应用来说，绝大部分的时间都是在等待某些事件的发生或响应某些状态的变化，比如用户的触摸事件、应用进入后台、网络请求成功刷新界面等等，而维护这些状态的变化，常常会使代码变得非常复杂，难以扩展。而 ReactiveCocoa 给出了一种非常好的解决方案，它使用信号来代表这些异步事件，提供了一种统一的方式来处理所有异步的行为，包括代理方法、block 回调、target-action 机制、通知、KVO 等：<br>然而，这些还只是 ReactiveCocoa 的冰山一角，它真正强大的地方在于我们可以对这些不同的信号进行任意地组合和链式操作，从最原始的输入 input 开始直至得到最终的输出 output为止</p>
</blockquote>
<h2 id="ReactiveCocoa解决的问题"><a href="#ReactiveCocoa解决的问题" class="headerlink" title="ReactiveCocoa解决的问题:"></a>ReactiveCocoa解决的问题:</h2><ol>
<li>传统iOS开发过程中,<strong>状态以及状态之间依赖过多的问题</strong></li>
<li>传统MVC架构的问题:Controller比较复杂,可测试性差</li>
<li><strong>提供统一的消息传递机制</strong></li>
<li>RAC使用信号监听，类似OC中的<code>KVO</code>机制，使用<code>Block</code>聚合代码逻辑，所以被称为：函数响应式编程。</li>
</ol>
<span id="more"></span>


<h2 id="ReactiveCocoa-的问题"><a href="#ReactiveCocoa-的问题" class="headerlink" title="ReactiveCocoa 的问题"></a>ReactiveCocoa 的问题</h2><p><code>RAC</code> 在应用中大量使用了 <code>block</code>，由于 <code>Objective-C</code> 语言的内存管理是基于引用计数 的，为了避免循环引用问题，在 <code>block</code> 中如果要引用 <code>self</code>，需要使用@weakify(self)和@strongify(self)来避免强引用。另外，在使用时应该注意 <code>block</code> 的嵌套层数，不恰当的滥用多层嵌套 <code>block</code> 可能给程序的可维护性带来灾难。</p>
<p>有些地方很容易被忽略，比如<strong>RACObserve</strong>(thing, keypath)，看上去并没有引用self，所以在subscribeNext时就忘记了weakify&#x2F;strongify。但事实上RACObserve总是会引用self，即使target不是self，所以只要有RACObserve的地方都要使用weakify&#x2F;strongify。</p>
<h2 id="ReactiveCocoa-的理解"><a href="#ReactiveCocoa-的理解" class="headerlink" title="ReactiveCocoa 的理解"></a>ReactiveCocoa 的理解</h2><p><a href="http://limboy.me/ios/2013/06/19/frp-reactivecocoa.html">leezhong博客</a></p>
<p>　 可以把信号想象成水龙头，只不过里面不是水，而是玻璃球(value)，直径跟水管的内径一样，这样就能保证玻璃球是依次排列，不会出现并排的情况(数据都是线性处理的，不会出现并发情况)。水龙头的开关默认是关的，除非有了接收方(subscriber)，才会打开。这样只要有新的玻璃球进来，就会自动传送给接收方。可以在水龙头上加一个过滤嘴(filter)，不符合的不让通过，也可以加一个改动装置，把球改变成符合自己的需求(map)。也可以把多个水龙头合并成一个新的水龙头(combineLatest:reduce:)，这样只要其中的一个水龙头有玻璃球出来，这个新合并的水龙头就会得到这个球。　</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代理方法</span></span><br><span class="line">[[<span class="keyword">self</span></span><br><span class="line">    rac_signalForSelector:<span class="keyword">@selector</span>(webViewDidStartLoad:)</span><br><span class="line">    fromProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">UIWebViewDelegate</span>)]</span></span><br><span class="line">    subscribeNext:^(<span class="type">id</span> x) &#123;</span><br><span class="line">        <span class="comment">// 实现 webViewDidStartLoad: 代理方法</span></span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// target-action</span></span><br><span class="line">[[<span class="keyword">self</span>.avatarButton</span><br><span class="line">    rac_signalForControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>]</span><br><span class="line">    subscribeNext:^(<span class="built_in">UIButton</span> *avatarButton) &#123;</span><br><span class="line">        <span class="comment">// avatarButton 被点击了</span></span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通知</span></span><br><span class="line">[[[<span class="built_in">NSNotificationCenter</span> defaultCenter]</span><br><span class="line">    rac_addObserverForName:kReachabilityChangedNotification object:<span class="literal">nil</span>]</span><br><span class="line">    subscribeNext:^(<span class="built_in">NSNotification</span> *notification) &#123;</span><br><span class="line">        <span class="comment">// 收到 kReachabilityChangedNotification 通知</span></span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// KVO</span></span><br><span class="line">[RACObserve(<span class="keyword">self</span>, username) subscribeNext:^(<span class="built_in">NSString</span> *username) &#123;</span><br><span class="line">    <span class="comment">// 用户名发生了变化</span></span><br><span class="line">&#125;];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://www.youtube.com/embed/fWV7xyN5CR8?rel=0">April 2014 Tech Talk: Reactive Cocoa - YouTube</a></li>
<li><a href="https://halfrost.com/reactivecocoa_racsignal/">ReactiveCocoa 中 RACSignal 是如何发送信号的</a></li>
<li><a href="https://juejin.im/post/578f49fa5bbb50005b95fb80">iOS ReactiveCocoa 最全常用API整理（可做为手册查询） - 掘金</a></li>
</ul>
<h2 id="总结图示"><a href="#总结图示" class="headerlink" title="总结图示"></a>总结图示</h2><p><img src="https://i.loli.net/2018/12/22/5c1de0224cd79.jpg"></p>
<ul>
<li>信号源：RACStream 及其子类；</li>
<li>订阅者：RACSubscriber 的实现类及其子类；</li>
<li>调度器：RACScheduler 及其子类；</li>
<li>清洁工：RACDisposable 及其子类。</li>
</ul>
<p><img src="https://i.loli.net/2018/12/22/5c1e0e05d4e87.png"></p>
<p><a href="http://blog.leichunfeng.com/blog/2015/12/25/reactivecocoa-v2-dot-5-yuan-ma-jie-xi-zhi-jia-gou-zong-lan/">ReactiveCocoa v2.5 源码解析之架构总览 - 雷纯锋的技术博客</a></p>
<h3 id="什么是ReactiveCocoa？"><a href="#什么是ReactiveCocoa？" class="headerlink" title="什么是ReactiveCocoa？"></a>什么是ReactiveCocoa？</h3><p><a href="https://github.com/ReactiveCocoa/ReactiveCocoa">ReactiveCocoa</a>（其简称为RAC）是由<a href="https://github.com/blog/1107-reactivecocoa-for-a-better-world">Github</a> 开源的一个应用于iOS和OS X开发的新框架。RAC具有函数式编程(FP)和响应式编程(RP)的特性。它主要吸取了.Net的 <a href="http://msdn.microsoft.com/en-us/data/gg577609">Reactive Extensions</a>的设计和实现。</p>
<p>ReactiveCocoa 的宗旨是Streams of values over time ，随着时间变化而不断流动的数据流。</p>
<p>ReactiveCocoa 主要解决了以下这些问题：</p>
<ul>
<li>UI数据绑定</li>
</ul>
<p>UI控件通常需要绑定一个事件，RAC可以很方便的绑定任何数据流到控件上。</p>
<ul>
<li>用户交互事件绑定</li>
</ul>
<p>RAC为可交互的UI控件提供了一系列能发送Signal信号的方法。这些数据流会在用户交互中相互传递。</p>
<ul>
<li>解决状态以及状态之间依赖过多的问题</li>
</ul>
<p>有了RAC的绑定之后，可以不用在关心各种复杂的状态，isSelect，isFinish……也解决了这些状态在后期很难维护的问题。</p>
<ul>
<li>消息传递机制的大统一</li>
</ul>
<h2 id="ReactiveCocoa-源码解析"><a href="#ReactiveCocoa-源码解析" class="headerlink" title="ReactiveCocoa 源码解析"></a>ReactiveCocoa 源码解析</h2><blockquote>
<p>对于一个应用来说，绝大部分的时间都是在等待某些事件的发生或响应某些状态的变化，比如用户的触摸事件、应用进入后台、网络请求成功刷新界面等等，而维护这些状态的变化，常常会使代码变得非常复杂，难以扩展。而 <code>ReactiveCocoa</code> 给出了一种非常好的解决方案，它使用信号来代表这些异步事件，提供了一种统一的方式来处理所有异步的行为，包括代理方法、<code>block</code> 回调、<code>target-action</code> 机制、通知、<code>KVO</code> 等：</p>
</blockquote>
<p><img src="https://i.loli.net/2018/12/29/5c27451072bcb.png" alt="WechatIMG414"></p>
<h3 id="例子代码"><a href="#例子代码" class="headerlink" title="例子代码"></a>例子代码</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代理方法</span></span><br><span class="line">[[<span class="keyword">self</span></span><br><span class="line">    rac_signalForSelector:<span class="keyword">@selector</span>(webViewDidStartLoad:)</span><br><span class="line">    fromProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">UIWebViewDelegate</span>)]</span></span><br><span class="line">    subscribeNext:^(<span class="type">id</span> x) &#123;</span><br><span class="line">        <span class="comment">// 实现 webViewDidStartLoad: 代理方法</span></span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// target-action</span></span><br><span class="line">[[<span class="keyword">self</span>.avatarButton</span><br><span class="line">    rac_signalForControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>]</span><br><span class="line">    subscribeNext:^(<span class="built_in">UIButton</span> *avatarButton) &#123;</span><br><span class="line">        <span class="comment">// avatarButton 被点击了</span></span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通知</span></span><br><span class="line">[[[<span class="built_in">NSNotificationCenter</span> defaultCenter]</span><br><span class="line">    rac_addObserverForName:kReachabilityChangedNotification object:<span class="literal">nil</span>]</span><br><span class="line">    subscribeNext:^(<span class="built_in">NSNotification</span> *notification) &#123;</span><br><span class="line">        <span class="comment">// 收到 kReachabilityChangedNotification 通知</span></span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// KVO</span></span><br><span class="line">[RACObserve(<span class="keyword">self</span>, username) subscribeNext:^(<span class="built_in">NSString</span> *username) &#123;</span><br><span class="line">    <span class="comment">// 用户名发生了变化</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>


<h2 id="RACSignal"><a href="#RACSignal" class="headerlink" title="RACSignal"></a>RACSignal</h2><blockquote>
<p>RACSignal 代表的是未来将会被传送的值，它是一种 push-driven 的流。RACSignal 可以向订阅者发送三种不同类型的事件：</p>
</blockquote>
<ul>
<li><p>next ：RACSignal 通过 next 事件向订阅者传送新的值，并且这个值可以为 nil ；</p>
</li>
<li><p>error ：RACSignal 通过 error 事件向订阅者表明信号在正常结束前发生了错误；</p>
</li>
<li><p>completed ：RACSignal 通过 completed 事件向订阅者表明信号已经正常结束，不会再有后续的值传送给订阅者。</p>
</li>
<li><p>ReactiveCocoa allows you to perform operations on</p>
</li>
<li><p>signals</p>
</li>
<li><p>map, filter, skip, take, throttle…</p>
</li>
<li><p>Operations return RACSignal, allowing method chaining</p>
</li>
</ul>
<p><img src="https://i.loli.net/2018/12/22/5c1df9e8aed17.jpg"></p>
<p><img src="https://i.loli.net/2018/12/22/5c1e02111f968.jpg"></p>
<p><img src="https://i.loli.net/2018/12/22/5c1e063be039c.jpg"></p>
<h2 id="RACSubject"><a href="#RACSubject" class="headerlink" title="RACSubject"></a>RACSubject</h2><blockquote>
<p>RACSubject 代表的是可以手动控制的信号，我们可以把它看作是 RACSignal 的可变版本，就好比 NSMutableArray 是 NSArray 的可变版本一样。RACSubject 继承自 RACSignal ，所以它可以作为信号源被订阅者订阅，同时，它又实现了 RACSubscriber 协议，所以它也可以作为订阅者订阅其他信号源，这个就是 RACSubject 为什么可以手动控制的原因：</p>
</blockquote>
<p><img src="https://i.loli.net/2018/12/22/5c1e119f0720d.jpg"></p>
<ul>
<li>RACSubject:信号提供者,自己可以充当信号,又能发送信号</li>
</ul>
<h4 id="创建方法"><a href="#创建方法" class="headerlink" title="创建方法:"></a>创建方法:</h4><ol>
<li>创建RACSubject</li>
<li>订阅信号</li>
<li>发送信号</li>
</ol>
<h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程:"></a>工作流程:</h4><ol>
<li>订阅信号,内部保存了订阅者,和订阅者相应block</li>
<li>当发送信号的,遍历订阅者,调用订阅者的nextBolck</li>
</ol>
<p> 注:如果订阅信号,必须在发送信号之前订阅信号,不然收不到信号,有利用区别<code>RACReplaySubject</code></p>
<p>根据官方的 Design Guidelines 中的说法，我们应该尽可能少地使用它。因为它太过灵活，我们可以在任何时候任何地方操作它，所以一旦过度使用，就会使代码变得非常复杂，难以理解。</p>
<h2 id="RACSequence"><a href="#RACSequence" class="headerlink" title="RACSequence"></a>RACSequence</h2><p>RACSequence 代表的是一个不可变的值的序列，与 RACSignal 不同，它是 pull-driven 类型的流。从严格意义上讲，RACSequence 并不能算作是信号源，因为它并不能像 RACSignal 那样，可以被订阅者订阅，但是它与 RACSignal 之间可以非常方便地进行转换。</p>
<p>从理论上说，一个 RACSequence 由两部分组成：</p>
<p>head ：指的是序列中的第一个对象，如果序列为空，则为 nil ；<br>tail ：指的是序列中除第一个对象外的其它所有对象，同样的，如果序列为空，则为 nil 。</p>
<h2 id="RACStream"><a href="#RACStream" class="headerlink" title="RACStream"></a>RACStream</h2><blockquote>
<p><code>RACStream</code> 信号源,是 <code>ReactiveCocoa</code> 中最核心的类，代表的是任意的值流，它是整个 <code>ReactiveCocoa</code> 得以建立的基石，下面是它的继承结构图：</p>
</blockquote>
<blockquote>
<p>你可以把它想象成水龙头中的水，当你打开水龙头时，水源源不断地流出来；你也可以把它想象成电，当你插上插头时，电静静地充到你的手机上；你还可以把它想象成运送玻璃珠的管道，当你打开阀门时，珠子一个接一个地到达。这里的水、电、玻璃珠就是我们所需要的值，而打开水龙头、插上插头、打开阀门就是订阅它们的过程。</p>
</blockquote>
<p><img src="https://i.loli.net/2018/12/22/5c1e104d85f5d.png"></p>
<h2 id="RACSubject的使用"><a href="#RACSubject的使用" class="headerlink" title="RACSubject的使用"></a>RACSubject的使用</h2><p>一般不推荐使用RACSubject，因为它过于灵活，滥用的话容易导致复杂度的增加。但有一些场景用一下还是比较方便的，比如ViewModel的errors。</p>
<ul>
<li><p>一、UI 操作，连续的动作与动画部分，例如某些控件跟随滚动。</p>
</li>
<li><p>二、网络库，因为数据是在一定时间后才返回回来，不是立刻就返回的。</p>
</li>
<li><p>三、刷新的业务逻辑，当触发点是多种的时候，业务往往会变得很复杂，用 delegate、notification、observe 混用，难以统一。这时用 RAC 可以保证上层的高度一致性，从而简化逻辑上分层。</p>
</li>
<li><p>基本上异步的事件能用 RAC 的都用的 RAC。</p>
</li>
<li><p>不过代理方法用 RAC 的比较少，比如 UITableView 的代理方法一般都是直接写了。</p>
</li>
<li><p>用 RACSubject + RACComand 来简化和统一应用的错误处理逻辑，这个算比较经典的吧。</p>
</li>
</ul>
<p><a href="https://blog.devtang.com/2016/01/03/reactive-cocoa-discussion/">ReactiveCocoa 讨论会 | 唐巧的博客</a></p>
<h3 id="RAC调试"><a href="#RAC调试" class="headerlink" title="RAC调试"></a>RAC调试</h3><ul>
<li>的确很痛苦，跟断点有的时候计算堆栈都要等几分钟。</li>
<li>关于调试，RAC 源码下有 instruments 的两个插件，方便大家使用。<br><img src="https://i.loli.net/2018/12/22/5c1e145311a2d.jpg"></li>
</ul>
<h2 id="RACCommand"><a href="#RACCommand" class="headerlink" title="RACCommand"></a>RACCommand</h2><ul>
<li>RACCommand: 处理事件</li>
<li>RACCommand: 不能返回一个空的信号</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RACCommand: 处理事件</span></span><br><span class="line"><span class="comment">// RACCommand: 不能返回一个空的信号</span></span><br><span class="line"><span class="comment">// input: RACCommand执行传入的参数</span></span><br><span class="line"><span class="comment">// initWithSignalBlock: RACCommand执行时候调用保存的Block</span></span><br><span class="line">    </span><br><span class="line">RACCommand *command = [[RACCommand alloc] initWithSignalBlock:^RACSignal * _Nonnull(<span class="type">id</span>  _Nullable input) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;命令的参数input = %@&quot;</span>, input);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [RACSignal createSignal:^RACDisposable * _Nullable(<span class="type">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通过订阅者发送数据</span></span><br><span class="line">        [subscriber sendNext:<span class="string">@&quot;订阅者发送的数据&quot;</span>];</span><br><span class="line">        <span class="comment">// 命令执行完毕</span></span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;disposableWithBlock&quot;</span>);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 订阅命令内部的信号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式一：</span></span><br><span class="line">RACSignal *signal = [command execute:<span class="string">@&quot;命令----数据&quot;</span>];</span><br><span class="line">[signal subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;x = %@&quot;</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二：</span></span><br><span class="line">[command.executionSignals.switchToLatest subscribeNext:^(RACSignal *signal) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;signal = %@&quot;</span>, signal);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行命令</span></span><br><span class="line">[command execute:<span class="string">@&quot;命令----数据&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听事件有没有完成</span></span><br><span class="line">[command.executing subscribeNext:^(<span class="built_in">NSNumber</span> * _Nullable x) &#123;</span><br><span class="line">    <span class="keyword">if</span>(x.boolValue)&#123;</span><br><span class="line">        <span class="comment">// 当前正在执行</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;当前正在执行&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 执行完成 / 没有执行</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;执行完成 / 没有执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>


<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，我们介绍完了 <code>ReactiveCocoa</code> 的四大核心组件，对它的架构有了宏观上的认识。它建立于 Monad 的概念之上，然后围绕其搭建了一系列完整的配套组件，它们共同支撑了 <code>ReactiveCocoa</code> 的强大功能。尽管，<code>ReactiveCocoa</code> 是一个重型的函数式响应式框架，但是它并不会对我们现有的代码构成侵略性，我们完全可以在一个单独的类中使用它，哪怕只是简单的一行代码，也是没有问题的。所以，如果你对 ReactiveCocoa 感兴趣的话，不妨就从现在开始尝试吧，Let’s go ！</p>
<h3 id="信号总结"><a href="#信号总结" class="headerlink" title="信号总结"></a>信号总结</h3><ul>
<li>首先在创建信号的时候，带进去一个已经订阅的Block（didSubscribe），把它保存在信号中，并没有执行；</li>
<li>在订阅信号的时候，带进去一个发送信号的Block（nextBlock），然后创建一个订阅者（RACSubscriber对象），订阅者会把nextBlock进行保存，</li>
<li>接着执行之前信号保存的didSubscribe这个Block，并将订阅者传递过去；</li>
<li>然后在didSubscribe回调里面，由订阅者发送信号，也就是执行之前保存的nextBlock；<br>最后在nextBlock（订阅回调）里面监听到发送的内容。</li>
</ul>
<p><a href="https://www.jianshu.com/p/3331588c16ca">iOS RAC学习之路（一） - 简书</a></p>
<p>RACSignal的2个方法</p>
<ul>
<li><ol>
<li>创建信号: createSignal, 创建一个signal对象</li>
</ol>
<ul>
<li>并且把createSignal方法的<code>didSubscribe</code>Block赋值给所创建的signal的<code>didSubscribe</code>属性，这个<code>didSubscribe</code>的入参是subscriber，返回RACDisposable。</li>
<li>RACSignal使用<code>didSubscribe</code>属性，封装了订阅者对这个信号的处理</li>
<li>RACSignal的类方法</li>
</ul>
</li>
<li><ol start="2">
<li>订阅信号: subscribeNext, 创建了一个RACSubscriber订阅者</li>
</ol>
<ul>
<li>订阅者会把nextBlock赋值给自己的next的属性，</li>
<li>然后，执行订阅操作［self subscribe：o］</li>
<li>didSubscribe是信号的invoke每个订阅者的Block属性, 订阅方法subscribe的实现：上面的代码很清晰，直接是self.didSubscribe(subscriber),</li>
<li>我们可以知道，刚刚创建的subscriber对象，直接传递给上文中我们提到的signal的didSubscribe属性。这样，我们可以解释上面的第二个和第三个问题，subscriber就是didSubscribe的形参，block对象是在subscribeNext的时候执行的，刚刚的订阅者对象作为参数传入，就是subscriber对象。</li>
<li>RACSignal的实例方法</li>
</ul>
</li>
</ul>
<h3 id="RAC的作用"><a href="#RAC的作用" class="headerlink" title="RAC的作用"></a>RAC的作用</h3><p>而RAC为MVVM带来很大的便利，比如RACCommand, UIKit的RAC Extension等等。<strong>使用MVVM不一定能减少代码量，但能降低代码的复杂度。</strong></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://tech.meituan.com/tag/ReactiveCocoa">标签归档 | ReactiveCocoa - 美团点评技术团队</a></li>
<li><a href="https://draveness.me/racsignal">『状态』驱动的世界：ReactiveCocoa</a></li>
<li><a href="https://www.jianshu.com/p/4fee21fb05b3">RAC基础学习一:信号和订阅者模式 - 简书</a></li>
</ol>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">MichaelMao</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://michaelmaomao.github.io/2018/12/29/ReactiveCocoa%E7%AC%94%E8%AE%B0(%E4%B8%80)%20%E2%80%94%E2%80%94%20%E6%A1%86%E6%9E%B6%E6%A6%82%E8%A7%88/">http://michaelmaomao.github.io/2018/12/29/ReactiveCocoa%E7%AC%94%E8%AE%B0(%E4%B8%80)%20%E2%80%94%E2%80%94%20%E6%A1%86%E6%9E%B6%E6%A6%82%E8%A7%88/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://michaelMaoMao.github.io">MMao</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/ReactiveCocoa/">ReactiveCocoa</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="https://pic-mike.oss-cn-hongkong.aliyuncs.com/Blog/avatar.png"><div class="post-qr-code__desc">我要吐槽下</div></div></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2018/12/29/ReactiveCocoa%E7%AC%94%E8%AE%B0(%E4%BA%8C)%20%E2%80%94%E2%80%94%20%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6/"><i class="fa fa-chevron-left">  </i><span>ReactiveCocoa笔记(二）—— 源码探究</span></a></div><div class="next-post pull-right"><a href="/2018/05/05/%E8%AF%BB%E3%80%8A%E7%A8%8B%E5%BA%8F%E6%98%AF%E5%A6%82%E4%BD%95%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84%E3%80%8B/"><span>读《程序是如何跑起来的》</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitment-container"></div><script>var gitment = new Gitment({
  owner: 'michaelMaoMao',
  repo: 'michaelMaoMao.github.io',
  oauth: {
    client_id: '98760fb6521b1f01477f',
    client_secret: '88766f6b64e79c5427ddc39db6fa3c42ee19f6d9'
  }
})
gitment.render('gitment-container')</script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2017 - 2025 By MichaelMao</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Hi, this is just a small place for reflect.</div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.6"></script><script src="/js/fancybox.js?version=1.5.6"></script><script src="/js/sidebar.js?version=1.5.6"></script><script src="/js/copy.js?version=1.5.6"></script><script src="/js/fireworks.js?version=1.5.6"></script><script src="/js/transition.js?version=1.5.6"></script><script src="/js/scroll.js?version=1.5.6"></script><script src="/js/head.js?version=1.5.6"></script><script src="/js/search/local-search.js"></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>